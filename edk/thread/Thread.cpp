#include "Thread.h"

/*
Library C++ Thread - Multi-threading controller.
Copyright (C) 1012 Eduardo Moura Sales Martins
This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
email: edimartin@gmail.com.br

AV: Walmor M. de Souza 392 Casa
Gravatai RS Brazil 94065100
*/

#ifdef printMessages
#warning "            Inside Thread.cpp"
#endif

namespace edk {
namespace multi {


    /**
     *  Thread class to create just one thread per time.
     *  @author EDIMARTIN MARTINS
     *  @version 0.9
     */

    /* {since=08/12}*/



//EDKThreadFunc
#ifdef WIN32
DWORD WINAPI edkThreadFunc(void*id){
    //test if have a threadFunc
    if(id){
        //then convert the pointer
        edk::multi::Thread* temp = (edk::multi::Thread*)id;

        //run the function
        temp->runFunc();
    }
    return (DWORD)NULL;
}
#elif defined WIN64
//WINDOWS 64
DWORD WINAPI edkThreadFunc(void*id){
    //test if have a threadFunc
    if(id){
        //then convert the pointer
        edk::multi::Thread* temp = (edk::multi::Thread*)id;

        //run the function
        temp->runFunc();
    }
    return (DWORD)NULL;
}
#elif defined __linux__
//LINUX
void* edkThreadFunc(void*id){
    //test if have a threadFunc
    if(id){
        //then convert the pointer
        edk::multi::Thread* temp = (edk::multi::Thread*)id;

        //run the function
        temp->runFunc();
    }
    return (void*)NULL;
}
#elif defined __APPLE__
//MAC OS
void* edkThreadFunc(void*id){
    //test if have a threadFunc
    if(id){
        //then convert the pointer
        edk::multi::Thread* temp = (edk::multi::Thread*)id;

        //run the function
        temp->runFunc();
    }
    return (void*)NULL;
}
#endif


/**
     *  Clean all the thread class atributes variables.
     */
void Thread::cleanThread()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-555c002f:13964a9dc6c:-8000:0000000000001184 begin
{
    //
    #ifdef WIN32
    //clean ID
    this->threadID=(HANDLE)0u;
    #elif defined WIN32
    //clean ID
    this->threadID=(HANDLE)0u;
    #elif defined __linux__
    //clean ID
    this->threadID=0u;
    #elif defined __APPLE__
    //clean ID
    this->threadID=0u;
    #endif

    //Clean Functions
    this->threadFunc=NULL;
    this->funcParameter=(void*)NULL;
}
// section 127-0-1-1-555c002f:13964a9dc6c:-8000:0000000000001184 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element








Thread::Thread()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7A1 begin
{
    this->cleanThread();
}
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7A1 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

Thread::Thread(classID (*threadFunction)(classID), classID parameter)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7A1 begin
{
    this->cleanThread();
    this->start(threadFunction, parameter);
}
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7A1 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

Thread::~Thread()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7B0 begin
{
    //Kill the Thread
    this->kill();
}
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7B0 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

bool Thread::start(classID (threadFunction)(classID), classID parameter)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7B2 begin
{
    //kill the previous thread
    this->kill();

    //test if the function is true
    if(threadFunction){
        //WINDOWS 32
        #ifdef WIN32
        DWORD flag;
        this->threadID = CreateThread(NULL, //
                                      (DWORD)NULL,        //
                                      edkThreadFunc,     // função da thread
                                      (void*)this,        // parâmetro da thread
                                      (DWORD)NULL,        //
                                      &flag);
        //test if create the thread
        if(this->threadID!=(HANDLE)0u){
        #elif defined WIN64
        //WINDOWS 64
        DWORD flag;
        this->threadID = CreateThread(NULL, //
                                      (DWORD)NULL,        //
                                      edkThreadFunc,     // função da thread
                                      (void*)this,        // parâmetro da thread
                                      (DWORD)NULL,        //
                                      &flag);
        //test if create the thread
        if(this->threadID!=(HANDLE)0u){
        #elif defined __linux__
        //LINUX
        pthread_create(&threadID,
                       NULL,
                       edkThreadFunc,
                       (void*)this);
        //test if create the thread
        if(this->threadID!=(pthread_t)0u){
        #elif defined __APPLE__
        //LINUX
        pthread_create(&threadID,
                       NULL,
                       edkThreadFunc,
                       (void*)this);
        //test if create the thread
        if(this->threadID!=(pthread_t)0u){
        #endif
            //copy the function
            this->threadFunc=threadFunction;
            //copy the parameter
            this->funcParameter=parameter;
            //then return true;
            return true;
        }
    }

    //clean
    this->cleanThread();
    //else he clean the func
    this->threadFunc=NULL;
    return false;
}
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7B2 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

bool Thread::start(classID (threadFunction)(classID))
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7B6 begin
{
    return this->start(threadFunction,(void*)NULL);
}
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7B6 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

bool Thread::runFunc()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7B9 begin
{
    if(this->threadFunc){
        //test if have parameter
        if(this->funcParameter){
            //then he cant run the function
            this->threadFunc((void*)this->funcParameter);
        }
        else{
            //then he cant run the function
            this->threadFunc((void*)NULL);
        }
        //clean the function
        this->threadFunc=NULL;
        this->funcParameter=NULL;

        //return true;
        return true;
    }
    //else return false
    return false;
}
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7B9 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

bool Thread::isAlive()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7BB begin
{
    //WINDOWS 32
    #ifdef WIN32
    if(this->threadID){
        //Then wait for the thread
        if(WaitForSingleObject(threadID, 0u) == WAIT_TIMEOUT){
            //thread still alive return true
            return true;
        }
    }
    #elif defined WIN64
    //WINDOWS 64
    if(this->threadID){
        //Then wait for the thread
        if(WaitForSingleObject(threadID, 0u) == WAIT_TIMEOUT){
            //thread still alive return true
            return true;
        }
    }
    #elif defined __linux__
    //WINDOWS 64
    if(this->threadID){
        //Then wait for the thread
        if(pthread_kill(this->threadID, 0u)!=3u){
            //thread still alive return true
            return true;
        }
    }
    #elif defined __APPLE__
    //WINDOWS 64
    if(this->threadID){
        //Then wait for the thread
        if(pthread_kill(this->threadID, 0u)){
            //thread still alive return true
            return true;
        }
    }
    #endif
    //pthread_kill(pthread_t thread, edk::int32 sig)
    //else return false;
    return false;
}
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7BB end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

bool Thread::waitEnd(uint64 milliseconds)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7BD begin
{
    //WINDOWS 32
    #ifdef WIN32
    if(this->threadID){
        //Then wait for the thread
        if(WaitForSingleObject(threadID, milliseconds) == WAIT_TIMEOUT){
            //thread still alive then
            return true;
        }
    }
    #elif defined WIN64
    //WINDOWS 64
    if(this->threadID){
        //Then wait for the thread
        if(WaitForSingleObject(threadID, milliseconds) == WAIT_TIMEOUT){
            //thread still alive then
            return true;
        }
    }
    #elif defined __linux__//Linux
        //first he sleep
        usleep(milliseconds*1000);
        //test if thread still alive
        if(this->isAlive()){
            //
            return true;
        }
    #elif __APPLE__//MacOS
        //first he sleep
        usleep(milliseconds*1000);
        //test if thread still alive
        if(this->isAlive()){
            //
            return true;
        }
    #endif

    //clean
    this->cleanThread();

    //else return false;
    return false;
}
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7BD end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

bool Thread::waitEnd()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7C1 begin
{
    bool ret=false;
    //WINDOWS 32
    #ifdef WIN32
    if(this->threadID){
        //Then wait for the thread
        WaitForSingleObject(threadID, INFINITE);
        //then return true
        ret = true;
    }
    #elif defined WIN64
    //WINDOWS 64
    if(this->threadID){
        //Then wait for the thread
        WaitForSingleObject(threadID, INFINITE);
        //then return true
        ret = true;
    }
    #elif defined __linux__
    //LINUX
    if(this->threadID){
        //then wait the end of the thread
        pthread_join(this->threadID,NULL);
        //then return true
        ret = true;
    }
    #elif defined __APPLE__
    //MAC OS
    if(this->threadID){
        //then return true
        ret = true;
    }
    #endif
    //clean
    this->cleanThread();

    //return true or false
    return ret;
}
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7C1 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

bool Thread::kill()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7C3 begin
{
    bool ret = false;
    //WINDOWS 32
    #ifdef WIN32
    if(this->threadID){
        //Finish the thread
        TerminateThread(this->threadID
                        ,(DWORD)NULL
                        );
        ret=true;
    }
    //clean ID
    this->threadID=(HANDLE)0u;
    #elif defined WIN64
    //WINDOWS 64
    if(this->threadID){
        //Finish the thread
        TerminateThread(this->threadID
                        ,(DWORD)NULL
                        );
        ret=true;
    }
    #elif defined __linux__
    //WINDOWS 64
    if(this->threadID){
        //Cancel the thread
        pthread_cancel(this->threadID);
        //Finish the thread
        ret=true;
    }
    #endif
    //clean
    this->cleanThread();

    //return true or false
    return ret;
}
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7C3 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void Thread::killThisThread()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7C5 begin
{
    //WINDOWS 32
    #ifdef WIN32
    //Finish the thread
    TerminateThread(NULL
                    ,(DWORD)NULL
                    );
    #elif defined WIN64
    //WINDOWS 64
    //Finish the thread
    TerminateThread(NULL
                    ,(DWORD)NULL
                    );
    #elif defined __linux__
    //LINUX
    //Exit the process
    pthread_exit(NULL);
    #elif defined __linux__
    //APPLE
    //Exit the process
    pthread_exit(NULL);
    #endif
}
// section 127-0-1-1-268c1826:13ad7e2c651:-8000:000000000000A7C5 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void Thread::killAllThreads(){
    //WINDOWS 32
    #ifdef WIN32
    /*
    //Finish the thread
    TerminateThread(NULL
                    ,(DWORD)NULL
                    );
    */
    #elif defined WIN64
    //WINDOWS 64
    /*
    //Finish the thread
    TerminateThread(NULL
                    ,(DWORD)NULL
                    );
    */
    #elif defined __linux__
    //LINUX
    //Exit the process
    pthread_cancel((pthread_t)NULL);
    #elif defined __linux__
    //APPLE
    //Exit the process
    pthread_cancel((pthread_t)NULL);
    #endif
}
}

} /* End of namespace edk */
