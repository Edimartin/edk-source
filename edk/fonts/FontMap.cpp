#include "FontMap.h"



edk::uint32 EDKFontTemplateSize = 4314u;
edk::char8 EDKFontTemplateName[20] = "EDKFontTemplate.png";
edk::uchar8 EDKFontTemplate[4314] = {
    137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,144,0,0 \
    ,1,0,8,6,0,0,0,92,87,255,79,0,0,0,6,98,75,71,68,0,255 \
    ,0,255,0,255,160,189,167,147,0,0,0,9,112,72,89,115,0,0,11,19,0 \
    ,0,11,19,1,0,154,156,24,0,0,0,7,116,73,77,69,7,227,9,16,19 \
    ,31,23,81,228,96,18,0,0,0,29,105,84,88,116,67,111,109,109,101,110,116 \
    ,0,0,0,0,0,67,114,101,97,116,101,100,32,119,105,116,104,32,71,73,77 \
    ,80,100,46,101,7,0,0,16,62,73,68,65,84,120,218,237,93,217,146,35,41 \
    ,12,236,174,168,207,237,249,26,251,127,103,159,188,81,83,13,82,234,224,172,84 \
    ,196,198,246,216,152,67,36,66,18,66,124,191,94,175,47,146,76,63,63,63,127 \
    ,165,239,223,239,247,119,207,122,102,162,131,240,32,69,232,204,88,137,215,149,131 \
    ,148,33,249,248,125,231,161,246,61,50,31,146,84,68,230,236,180,12,166,86,225 \
    ,231,59,169,51,210,239,179,24,45,213,143,148,153,141,36,158,222,199,243,243,243 \
    ,243,87,226,177,6,24,68,8,148,120,120,68,86,5,210,153,218,170,248,252,246 \
    ,250,183,71,111,64,250,131,148,153,89,2,101,128,30,225,179,86,70,148,64,37 \
    ,68,151,58,175,129,67,155,176,218,119,165,213,115,5,153,151,137,37,134,244,144 \
    ,134,18,143,180,173,168,133,196,212,234,169,73,160,90,63,62,159,31,37,17,55 \
    ,131,184,151,128,87,234,103,169,255,86,201,134,172,192,107,91,210,164,215,182,12 \
    ,132,207,200,4,246,220,70,239,91,233,103,1,190,223,239,239,211,186,231,101,173 \
    ,48,143,178,222,75,114,212,218,185,75,223,82,63,145,50,82,91,168,110,243,169 \
    ,251,90,87,11,222,148,234,191,182,123,72,171,170,244,121,116,11,139,136,91,43 \
    ,131,164,242,59,88,133,200,92,100,73,160,154,212,63,61,90,61,210,89,73,193 \
    ,214,86,110,169,156,4,100,73,204,107,58,93,169,61,205,218,68,165,36,194,131 \
    ,44,221,14,217,45,162,245,150,254,62,145,9,106,109,158,106,147,218,75,90,68 \
    ,22,6,186,173,92,245,135,12,41,141,232,81,94,11,23,217,13,78,239,164,151 \
    ,42,67,202,88,193,161,125,143,232,46,72,153,149,64,216,162,79,222,223,124,243 \
    ,44,204,175,212,91,153,61,219,89,88,134,133,119,18,30,207,165,12,192,242,48 \
    ,149,68,0,145,198,17,117,32,82,136,206,168,101,210,211,204,70,148,82,134,141 \
    ,12,0,144,23,8,200,89,147,100,86,75,190,12,196,212,45,253,38,227,224,53 \
    ,26,22,178,98,232,72,138,14,100,113,104,161,7,149,17,111,168,228,170,47,121 \
    ,123,165,131,78,203,120,118,11,11,233,170,68,71,61,152,218,225,97,11,51,212 \
    ,19,199,98,237,115,207,113,205,162,14,92,121,91,250,175,106,133,69,2,188,238 \
    ,82,32,34,21,172,146,202,59,161,72,159,179,199,133,6,120,245,4,143,167,189 \
    ,3,29,64,207,1,33,128,184,131,39,10,162,222,36,245,23,57,212,237,61,23 \
    ,181,207,79,244,135,189,39,104,53,64,68,183,137,210,120,145,216,171,236,62,89 \
    ,141,144,211,130,186,187,5,132,118,168,197,224,175,135,142,146,85,134,44,144,158 \
    ,125,70,140,133,217,172,56,41,122,226,240,248,81,172,129,90,173,244,9,52,214 \
    ,199,51,30,79,93,150,109,223,18,195,164,181,231,13,136,71,172,77,147,4,178 \
    ,48,77,11,221,136,250,129,188,150,88,4,68,25,64,68,183,157,72,24,203,8 \
    ,201,84,11,191,57,35,157,178,196,255,180,182,192,238,91,90,84,15,200,224,201 \
    ,236,142,196,140,16,225,165,207,194,120,148,49,158,150,142,7,34,88,198,19,195 \
    ,57,72,4,16,137,0,130,77,99,210,230,0,26,121,4,66,160,78,160,68,255 \
    ,249,243,231,235,235,235,235,75,178,206,122,152,169,81,23,123,173,174,172,76,23 \
    ,181,186,158,20,11,244,75,2,125,192,115,255,187,54,25,222,21,171,165,119,185 \
    ,95,159,141,156,139,101,157,216,163,0,217,241,12,175,235,22,150,117,44,160,213 \
    ,81,219,114,178,2,216,34,229,158,0,34,49,30,40,115,178,145,212,37,40,179 \
    ,45,183,84,107,147,137,38,145,232,165,107,105,231,101,51,130,240,218,167,127,0 \
    ,116,213,123,106,58,80,52,35,68,237,247,165,191,165,131,194,218,253,114,9,176 \
    ,165,107,195,189,105,182,60,76,81,105,61,173,39,186,182,101,89,20,215,123,54 \
    ,137,209,19,102,201,119,24,85,204,163,201,51,209,45,124,249,171,205,22,189,100 \
    ,244,118,160,101,45,179,108,187,209,237,62,139,207,191,116,160,215,235,245,165,29 \
    ,176,182,184,253,224,177,238,86,223,2,50,148,237,30,91,178,196,231,163,228,7 \
    ,170,153,240,25,157,70,116,32,132,169,210,189,176,222,18,196,194,112,75,48,221 \
    ,72,229,30,93,164,83,30,101,148,148,104,73,212,163,245,100,172,120,36,67,217 \
    ,106,82,49,178,29,78,31,15,244,52,207,238,106,188,97,126,160,77,37,3,1 \
    ,52,17,147,72,117,98,60,16,137,0,34,17,64,164,69,233,44,105,245,154,238 \
    ,129,196,195,72,122,140,245,54,69,228,214,169,54,46,239,237,213,140,113,173,102 \
    ,237,149,198,85,204,84,143,156,59,89,38,186,228,131,65,19,67,69,83,227,90 \
    ,67,48,74,109,182,24,215,44,38,61,146,200,65,26,215,81,42,164,29,234,73 \
    ,147,128,76,84,86,94,229,12,166,246,244,246,222,251,134,94,93,110,5,30,105 \
    ,174,155,152,241,214,198,34,3,43,189,203,64,138,171,19,165,178,210,174,163,37 \
    ,132,56,75,141,182,142,27,46,13,14,125,60,197,82,143,165,140,212,118,45,142 \
    ,8,41,227,221,122,51,182,103,79,174,3,237,105,211,123,189,103,239,85,81,3 \
    ,140,244,98,97,9,220,210,83,154,218,203,62,145,184,34,169,158,232,59,105,61 \
    ,116,158,40,136,212,45,44,218,161,140,129,33,19,184,194,132,180,36,139,196,64 \
    ,231,216,195,131,243,201,147,48,171,238,98,217,162,162,239,186,121,119,141,127,28 \
    ,137,119,229,184,229,107,193,89,49,59,179,95,4,236,181,152,178,130,210,80,157 \
    ,235,222,206,63,225,28,154,35,49,235,17,123,139,195,13,81,182,51,156,123,86 \
    ,165,31,105,43,154,197,213,82,71,43,63,144,86,150,111,101,144,66,196,179,48 \
    ,18,1,68,34,128,72,4,16,137,0,34,145,140,228,114,36,90,67,47,172,231 \
    ,83,94,243,220,235,86,64,251,99,189,139,239,113,79,148,92,41,218,213,103,212 \
    ,45,97,121,167,13,157,143,227,90,8,201,122,46,189,236,82,187,48,167,229,255 \
    ,169,49,14,101,90,45,36,3,189,192,151,121,91,20,77,62,129,94,176,140,180 \
    ,161,205,23,178,24,181,92,77,7,82,72,67,176,85,122,89,153,128,182,231,57 \
    ,225,246,244,103,53,138,190,1,151,162,3,181,126,94,169,199,33,174,197,235,58 \
    ,11,136,122,158,47,122,230,242,204,66,162,84,79,175,103,15,90,172,176,22,188 \
    ,233,9,158,235,27,23,200,219,38,205,149,104,107,192,84,143,184,96,132,1,72 \
    ,25,52,237,202,8,48,181,150,238,94,16,29,158,206,140,138,35,206,214,127,106 \
    ,99,107,41,81,44,147,52,234,145,191,52,0,245,4,73,139,173,115,7,178,128 \
    ,104,196,216,143,222,18,6,121,218,209,171,11,120,24,184,75,70,213,81,253,63 \
    ,175,251,95,52,158,165,6,10,233,22,128,166,95,32,14,59,244,157,119,36,178 \
    ,47,170,84,74,109,106,227,246,72,154,214,192,209,176,193,120,32,82,238,22,70 \
    ,34,17,64,36,2,136,68,0,145,30,96,197,17,64,36,232,196,94,52,227,209 \
    ,56,30,45,132,35,171,30,164,174,172,120,151,22,113,51,104,28,143,101,252,25 \
    ,137,221,165,118,188,207,166,31,247,74,107,225,28,72,200,71,86,61,187,147,197 \
    ,89,91,42,103,61,14,65,175,50,123,230,226,152,157,209,209,21,152,217,143,140 \
    ,155,187,89,227,200,88,112,37,112,89,79,33,142,209,147,33,13,164,21,243,71 \
    ,77,92,118,210,136,25,164,246,81,234,84,70,28,10,242,68,193,108,247,219,45 \
    ,58,138,4,112,132,135,89,82,108,52,255,154,29,166,90,66,39,118,210,127,144 \
    ,109,55,59,5,206,72,254,29,61,152,25,189,65,49,163,116,138,30,182,102,191 \
    ,35,59,138,127,71,6,51,189,91,219,76,202,47,234,11,105,145,113,35,75,175 \
    ,154,34,30,104,37,5,206,3,34,107,2,165,44,115,183,181,53,53,116,11,67 \
    ,226,75,144,251,89,150,151,151,181,183,192,180,126,89,234,145,242,42,102,36,168 \
    ,68,251,124,151,194,104,236,79,228,69,235,214,18,223,29,15,196,116,118,164,175 \
    ,175,132,28,137,189,50,177,147,230,115,109,132,36,16,137,212,220,140,39,17,64 \
    ,36,18,14,160,217,83,231,146,230,163,95,58,80,198,3,41,153,214,89,86,157 \
    ,145,122,172,191,141,164,206,181,180,213,51,255,0,188,133,69,156,100,45,6,209 \
    ,226,225,23,235,216,122,78,142,245,129,148,41,205,248,157,205,242,30,207,71,173 \
    ,6,130,116,0,161,62,129,150,207,98,34,146,194,251,196,164,246,36,102,36,20 \
    ,163,197,22,228,81,43,144,49,213,110,226,90,66,144,15,235,202,66,195,48,208 \
    ,244,118,104,54,52,137,169,72,61,181,254,222,235,65,218,149,198,159,45,125,178 \
    ,98,179,36,208,126,198,228,9,65,62,172,29,241,60,170,102,125,42,211,170,132 \
    ,74,125,202,14,139,29,145,177,36,35,110,168,85,191,79,239,96,102,49,247,121 \
    ,140,50,145,31,136,52,159,194,63,211,98,157,22,64,79,121,67,108,71,16,29 \
    ,158,129,104,138,228,125,50,107,121,159,209,50,90,18,110,41,30,72,83,162,145 \
    ,0,127,203,228,69,115,247,180,104,43,67,135,170,241,153,167,241,13,20,87,143 \
    ,46,185,170,46,119,16,48,60,255,139,16,37,208,87,238,83,149,51,182,71,0 \
    ,145,184,133,145,246,164,147,44,224,246,125,221,74,173,74,253,177,210,0,159,172 \
    ,228,35,238,18,207,111,163,22,225,73,240,236,235,82,208,222,43,201,56,39,164 \
    ,14,68,10,45,232,243,142,116,52,46,164,180,95,102,196,151,148,190,239,153,134 \
    ,174,71,25,73,90,204,14,158,187,36,59,238,3,68,227,66,180,35,136,26,227 \
    ,208,84,121,232,115,149,61,40,51,67,89,109,124,53,189,38,51,4,197,235,52 \
    ,149,230,243,104,205,116,109,50,102,0,8,162,115,101,28,61,148,22,76,237,190 \
    ,126,139,4,14,30,62,107,137,37,142,30,171,119,149,12,101,171,40,199,51,209 \
    ,48,37,250,169,25,90,119,75,74,113,140,96,160,244,54,58,250,187,108,221,69 \
    ,75,48,213,234,197,234,85,164,112,205,167,244,255,89,152,55,249,183,100,61,105 \
    ,1,241,214,178,222,219,20,218,237,135,146,245,104,181,230,36,80,69,172,48,75 \
    ,223,173,191,205,160,95,0,66,27,98,126,32,242,104,168,14,68,240,236,65,223 \
    ,175,215,203,28,159,178,83,60,75,75,23,192,19,248,194,120,32,18,183,176,209 \
    ,146,134,0,10,154,203,45,204,195,153,193,67,16,77,34,129,102,185,237,122,7 \
    ,112,9,208,179,222,204,157,6,64,37,38,246,236,200,44,231,97,8,208,9,162 \
    ,138,21,230,77,112,176,131,169,75,203,50,121,11,171,189,148,167,137,250,25,165 \
    ,7,210,231,140,232,188,107,221,53,221,206,202,67,52,148,213,219,86,180,76,85 \
    ,2,181,92,169,232,219,170,189,164,75,102,127,44,137,157,180,118,180,36,238,72 \
    ,61,173,203,192,0,106,241,138,77,175,107,196,104,159,179,250,83,59,91,179,244 \
    ,71,2,15,82,79,175,50,102,29,40,83,87,232,165,3,245,146,64,222,87,171 \
    ,151,151,64,181,193,107,43,20,57,9,142,230,81,140,70,2,102,247,217,42,117 \
    ,162,227,170,129,104,134,216,238,247,251,253,157,154,39,186,39,128,180,109,162,247 \
    ,150,138,94,40,160,35,145,36,234,47,37,160,239,236,47,106,114,152,138,74,22 \
    ,77,207,218,37,135,206,246,142,196,145,78,59,130,98,109,26,114,181,153,160,161 \
    ,14,68,34,17,64,164,129,0,66,95,28,214,190,139,150,33,81,2,145,8,32 \
    ,18,1,68,34,57,168,122,177,144,206,187,178,62,134,164,176,185,243,173,148,109 \
    ,95,227,51,122,144,58,213,89,24,163,242,108,70,65,109,210,209,171,210,26,159 \
    ,151,139,7,170,209,42,217,179,70,199,21,93,1,84,251,191,149,207,37,16,205 \
    ,20,15,116,162,98,248,201,228,229,143,148,23,41,34,129,144,122,122,149,161,14 \
    ,148,164,3,101,215,179,164,14,68,34,89,233,124,138,228,64,183,129,213,244,191 \
    ,105,204,120,18,201,67,116,36,146,8,32,18,1,68,34,128,230,86,164,25,18 \
    ,178,152,21,134,220,119,162,165,67,0,133,193,85,123,138,200,11,80,58,64,219 \
    ,204,85,137,222,239,247,247,217,186,65,13,28,200,121,139,244,59,233,164,123,6 \
    ,102,175,114,142,88,235,179,214,255,179,165,100,177,128,200,211,222,21,68,163,39 \
    ,76,186,130,60,115,226,172,104,159,207,154,232,247,158,155,104,224,64,129,133,102 \
    ,161,143,94,103,206,30,59,2,102,75,153,140,241,69,245,85,8,64,200,106,206 \
    ,88,241,8,67,74,58,82,109,66,51,20,243,236,177,91,78,233,165,112,13,52 \
    ,158,40,83,154,91,127,127,74,29,66,114,219,244,210,59,164,247,62,51,146,34 \
    ,244,28,187,164,39,34,146,7,9,248,234,165,147,193,241,64,222,152,152,86,0 \
    ,203,146,64,45,199,238,109,247,106,28,120,173,84,107,255,188,109,28,165,137,174 \
    ,13,78,43,211,51,48,237,254,100,102,237,51,171,14,224,29,251,189,108,196,113 \
    ,121,143,112,212,182,173,44,126,122,218,56,145,45,194,83,6,205,112,134,74,169 \
    ,150,214,76,214,216,45,139,69,115,119,100,36,253,180,142,63,164,68,143,246,65 \
    ,220,25,118,87,158,35,162,188,7,213,86,48,2,198,22,139,32,187,207,53,122 \
    ,68,60,16,189,211,237,136,167,241,36,2,136,68,0,145,22,165,243,9,131,164 \
    ,238,211,9,64,140,209,201,81,216,209,235,200,89,103,119,209,50,145,190,28,181 \
    ,6,119,137,224,187,62,122,114,255,175,165,91,2,153,212,145,60,206,234,203,177 \
    ,187,52,168,109,103,35,124,49,31,47,118,207,227,29,9,56,158,195,218,42,128 \
    ,120,165,121,204,202,31,1,30,169,47,86,73,116,90,86,208,44,247,177,45,101 \
    ,34,226,60,187,173,82,29,214,80,142,44,157,72,218,194,44,137,223,205,158,232 \
    ,25,114,210,88,202,212,78,187,61,47,232,104,73,164,180,45,13,61,54,176,128 \
    ,200,171,80,91,95,40,82,179,115,68,69,100,207,156,52,209,92,59,150,83,110 \
    ,111,91,153,91,93,228,2,65,214,163,55,53,218,94,2,105,0,106,213,86,111 \
    ,240,120,223,189,245,132,234,94,191,63,188,3,139,196,205,244,44,211,115,92,163 \
    ,193,163,149,169,189,204,141,196,55,213,198,254,168,236,28,146,4,90,213,89,89 \
    ,202,203,88,42,83,2,37,82,143,201,10,35,173,65,119,96,160,119,187,238,224 \
    ,64,234,33,128,30,0,36,100,242,37,201,18,241,3,241,52,254,65,206,203,171 \
    ,46,148,85,55,37,208,134,210,40,226,102,176,234,134,76,113,71,10,209,225,21 \
    ,109,90,121,237,187,235,239,35,98,181,229,233,186,101,188,153,252,89,169,63,213 \
    ,195,84,175,66,86,50,9,173,142,171,210,96,107,159,89,251,158,101,249,180,228 \
    ,15,50,246,89,250,179,252,22,150,21,4,199,44,253,62,250,5,32,196,201,182 \
    ,98,25,203,10,181,72,182,17,101,44,160,111,93,230,40,21,234,241,84,101,207 \
    ,50,86,241,46,221,66,173,93,157,238,89,166,86,118,68,25,83,72,235,170,101 \
    ,60,126,16,235,67,42,163,203,12,181,194,52,23,247,170,101,238,159,103,69,3 \
    ,246,8,163,176,148,25,73,91,59,18,91,228,52,138,190,86,157,93,102,42,0 \
    ,205,198,156,104,153,72,186,25,233,173,174,153,2,231,166,113,36,94,149,54,77 \
    ,113,91,169,140,39,167,145,229,133,194,25,202,112,11,107,72,104,238,31,107,238 \
    ,71,110,101,5,9,244,100,66,164,152,100,197,245,44,83,43,59,162,12,15,83 \
    ,23,180,124,184,133,45,96,173,17,60,4,144,91,79,34,81,7,34,205,8,32 \
    ,36,142,103,213,184,162,172,173,112,166,152,161,72,223,210,1,132,94,64,91,49 \
    ,174,40,123,43,156,37,102,168,135,81,240,253,122,189,168,68,58,149,109,242,232 \
    ,98,198,163,15,124,160,159,73,140,158,173,76,134,4,94,37,83,73,182,52,58 \
    ,172,162,24,217,179,239,199,11,181,83,244,25,202,68,253,66,79,127,139,213,101 \
    ,133,237,198,52,107,204,208,10,227,71,66,96,208,177,75,101,142,90,35,79,2 \
    ,145,37,102,104,165,113,35,227,138,150,57,61,157,218,9,60,22,203,165,246,138 \
    ,226,236,32,178,60,124,83,211,135,107,101,78,173,145,221,65,228,137,25,218,197 \
    ,250,202,120,43,237,136,54,190,147,20,66,20,237,221,76,247,104,110,164,179,183 \
    ,227,105,230,149,40,253,27,201,112,186,227,216,181,50,176,35,241,233,126,32,100 \
    ,155,155,113,92,173,157,159,140,7,34,245,247,3,145,72,4,16,137,0,34,17 \
    ,64,164,93,0,100,137,147,65,202,246,114,52,206,152,96,170,7,127,102,233,143 \
    ,57,193,148,229,62,183,228,6,151,34,9,209,195,205,25,19,76,69,249,131,142 \
    ,125,150,254,20,243,3,105,62,5,52,25,128,230,59,202,124,189,175,133,143,195 \
    ,58,33,25,252,89,173,63,244,3,85,68,56,163,13,49,58,45,12,92,185,140 \
    ,53,154,239,158,92,97,118,47,51,18,126,210,162,76,81,2,205,150,255,38,251 \
    ,201,34,107,152,231,108,225,170,51,241,248,180,104,225,171,149,201,190,165,192,132 \
    ,10,149,45,108,215,244,118,222,252,64,90,100,30,98,173,245,40,67,71,98,71 \
    ,229,88,138,119,105,145,6,239,113,74,244,174,132,74,17,171,47,137,121,18,111 \
    ,74,116,45,222,23,137,9,158,185,76,150,111,101,213,88,159,214,101,232,7,162 \
    ,31,136,91,88,139,173,142,68,37,154,68,0,145,8,32,18,1,100,85,70,87 \
    ,140,43,218,121,236,104,191,174,97,54,104,219,38,43,12,53,155,179,253,31,136 \
    ,105,89,123,59,93,250,119,75,107,174,229,216,45,227,178,140,185,105,56,135,53 \
    ,142,103,181,184,162,76,176,204,18,51,100,253,45,227,129,58,72,143,8,179,119 \
    ,26,255,135,78,84,44,162,43,126,247,12,101,40,243,103,12,1,137,70,33,148 \
    ,218,43,198,68,75,175,248,125,2,173,86,200,62,102,205,80,86,123,238,64,227 \
    ,199,238,146,89,205,15,52,34,187,231,140,162,59,67,82,173,58,110,107,66,173 \
    ,95,249,129,74,133,159,154,157,227,41,122,15,250,102,153,132,141,163,38,238,159 \
    ,34,158,17,127,73,73,175,122,82,220,16,148,31,200,19,125,247,68,218,141,47 \
    ,165,183,210,180,49,171,65,245,25,150,198,78,86,24,42,109,102,142,151,210,198 \
    ,239,245,165,209,15,68,63,87,136,120,152,74,240,132,136,1,101,15,114,77,180 \
    ,208,223,8,32,42,251,33,250,15,37,128,8,4,254,156,136,240,0,0,0,0 \
    ,73,69,78,68,174,66,96,130
    };

edk::fonts::FontMap::FontLine::FontLine(edk::uint32 size){
    this->size = size;
    if(this->size){
        this->line = new edk::uint32[this->size];
        if(line){
            //clean the line
            for(edk::uint32 i=0u;i<this->size;i++){
                this->line[i]=0u;
            }
        }
        else{
            this->size=0u;
        }
    }
}
edk::fonts::FontMap::FontLine::~FontLine(){
    //delete the line
    if(this->line) delete[] this->line;
}
//get the size
edk::uint32 edk::fonts::FontMap::FontLine::getSize(){
    return size;
}
//return true if have the line
bool edk::fonts::FontMap::FontLine::haveLine(){
    if(this->line) return true;
    return false;
}
//set the value
bool edk::fonts::FontMap::FontLine::setValue(edk::uint32 position,edk::uint32 value){
    //test if have the position
    if(this->havePosition(position)){
        //set the value
        this->line[position] = value;
        return true;
    }
    return false;
}
//get the value
edk::uint32 edk::fonts::FontMap::FontLine::getValue(edk::uint32 position){
    if(this->havePosition(position)){
        //return the value
        return this->line[position];
    }
    return 0u;
}
//test if have position
bool edk::fonts::FontMap::FontLine::havePosition(edk::uint32 position){
    if(this->line && position<this->size){
        return true;
    }
    return false;
}


edk::fonts::FontMap::FontMap(){
    this->set = NULL;
    this->map.cleanTiles();
    this->originID = this->lastID = 0u;
    this->origin = this->last = edk::vec2ui32(0u,0u);
    this->speedOrigin = this->fasterOrigin = 1.f;
    this->speedLast = 1.f;
    this->fasterLast = 4.f;
    this->animOrigin.setSpeed(this->speedOrigin);
    this->animLast.setSpeed(this->speedLast);
    this->forceSpeedOrigin = forceSpeedLast = false;
    this->forceSpeedOriginValue = this->forceSpeedLastValue = 1.f;
    this->enterOrigin = this->enterLast = false;
    this->write=0u;

    //set the animation callback
    this->animOrigin.setAnimationCallback(this);
    this->animLast.setAnimationCallback(this);
    this->maxSizeLine=0u;

    //load the templateFont
    this->loadFontImageFromMemory(EDKFontTemplateName,EDKFontTemplate,EDKFontTemplateSize);
}
edk::fonts::FontMap::~FontMap(){
    this->removeFontImage();
    this->cleanLines();
}

//gete the tileID
edk::uint32 edk::fonts::FontMap::getTileID(edk::char8* str,edk::uint8* jump){
    //
    if(str && jump){
        *jump=1u;
        if((edk::uint8)*str==195u){
            *jump+=1u;
            str++;
            switch((edk::uint8)*str){
            case 128u:
                //printf("\nCrase A");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 129u:
                //printf("\nAcento A");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 130u:
                //printf("\nChapeu A");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 131u:
                //printf("\nTio A");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 132u:
                //printf("\nTrema A");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 135u:
                //printf("\nCedilha Maiusculo");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 136u:
                //printf("\nCrase E");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 137u:
                //printf("\nAcento E");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 138u:
                //printf("\nChapeu E");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 139u:
                //printf("\nTrema E");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 140u:
                //printf("\nCrase I");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 141u:
                //printf("\nAcento I");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 142u:
                //printf("\nChapeu I");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 143u:
                //printf("\nTrema I");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 145u:
                //printf("\nTio N");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 146u:
                //printf("\nCrase O");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 147u:
                //printf("\nAcento O");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 148u:
                //printf("\nChapeu O");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 149u:
                //printf("\nTio O");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 150u:
                //printf("\nTrema O");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 153u:
                //printf("\nCrase U");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 154u:
                //printf("\nAcento U");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 155u:
                //printf("\nChapeu U");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 156u:
                //printf("\nTrema U");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 157u:
                //printf("\nAcento Y");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 160u:
                //printf("\nCrase a");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 161u:
                //printf("\nAcento a");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 162u:
                //printf("\nChapeu a");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 163u:
                //printf("\nTio a");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 164u:
                //printf("\nTrema a");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 167u:
                //printf("\nCedilha Minusculo");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 168u:
                //printf("\nCrase e");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 169u:
                //printf("\nAcento e");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 170u:
                //printf("\nChapeu e");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 171u:
                //printf("\nTrema e");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 172u:
                //printf("\nCrase i");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 173u:
                //printf("\nAcento i");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 174u:
                //printf("\nChapeu i");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 175u:
                //printf("\ntrema i");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 177u:
                //printf("\nTio n");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 178u:
                //printf("\nCrase o");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 179u:
                //printf("\nAcento o");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 180u:
                //printf("\nChapeu o");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 181u:
                //printf("\nTio o");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 182u:
                //printf("\nTrema o");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 185u:
                //printf("\nCrase u");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 186u:
                //printf("\nAcento u");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 187u:
                //printf("\nChapeu u");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 188u:
                //printf("\nTrema u");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 189u:
                //printf("\nAcento y");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            default:
                *jump-=1u;
                str--;
            }
        }
        else if((edk::uint8)*str==225u){
            *jump+=1u;
            str++;
            if((edk::uint8)*str==186u){
                *jump+=1u;
                str++;
                if((edk::uint8)*str==189u){
                    //printf("\nTio e");
                    return 32u;
                }
                *jump-=1u;
                str--;
            }
            *jump-=1u;
            str--;
        }
        else if((edk::uint8)*str==196u){
            *jump+=1u;
            str++;
            if((edk::uint8)*str==169u){
                //printf("\nTio i");
                return 32u;
            }
            *jump-=1u;
            str--;
        }
        else if((edk::uint8)*str==197u){
            *jump+=1u;
            str++;
            if((edk::uint8)*str==169u){
                //printf("\nTio u");
                return 32u;
            }
            *jump-=1u;
            str--;
        }
        return (edk::uchar8)*str;
    }
    return 0u;
}
//return the wordSize
edk::uint32 edk::fonts::FontMap::wordSize(edk::char8* str){
    if(str){
        edk::uint32 size = 0u;
        edk::uint8 jump=0u;
        edk::uint32 c = this->getTileID(str,&jump);
        while(c){
            if(c == ' ' || c==10 || c == 13){
                break;
            }
            size++;
            str+=jump;
            c = this->getTileID(str,&jump);
        }
        return size;
    }
    return 0u;
}
//return the lineSize
edk::uint32 edk::fonts::FontMap::lineSize(edk::char8* str){
    if(str){
        edk::uint32 size = 0u;
        edk::uint8 jump=0u;
        edk::uint32 c = this->getTileID(str,&jump);
        while(c){
            if(c==10 || c == 13){
                break;
            }
            size++;
            str+=jump;
            c = this->getTileID(str,&jump);
        }
        return size;
    }
    return 0u;
}

//clean lines
void edk::fonts::FontMap::cleanLines(){
    edk::uint32 size = this->lines.size();
    edk::fonts::FontMap::FontLine * temp = NULL;
    for(edk::uint32 i=0u;i<size;i++){
        temp = this->lines[i];
        if(temp){
            //
            delete temp;
        }
    }
    this->lines.clean();
    this->maxSizeLine=0u;
}
//create new line
edk::fonts::FontMap::FontLine* edk::fonts::FontMap::newLine(edk::uint32 size){
    //test the size
    if(size){
        //create a new line
        edk::fonts::FontMap::FontLine* line = new edk::fonts::FontMap::FontLine(size);
        if(line){
            //test if the line was created
            if(line->getSize() == size){
                //add the line to the stack
                edk::uint32 sizeTemp = this->lines.size();
                this->lines.pushBack(line);
                if(sizeTemp<this->lines.size()){
                    if(size>this->maxSizeLine) this->maxSizeLine = size;
                    //return the line
                    return line;
                }
            }
            delete line;
        }
    }
    return NULL;
}
//return the last line on the map
edk::fonts::FontMap::FontLine* edk::fonts::FontMap::getLastLine(){
    edk::fonts::FontMap::FontLine* ret=NULL;
    //test if have some lines
    if(this->lines.size()){
        //get the last line
        ret = this->lines.get(this->lines.size()-1u);
    }
    return ret;
}
//copy the text to the map
bool edk::fonts::FontMap::copyLinesToMap(){
    //test if have lines
    edk::uint32 size=this->lines.size();
    edk::uint32 sizeLine=0u;
    if(size){
        //
        edk::fonts::FontMap::FontLine *temp=NULL;
        for(edk::uint32 i=0u;i<size;i++){
            //load the line
            temp = this->lines[i];
            if(temp){
                sizeLine=temp->getSize();
                for(edk::uint32 j=0u;j<sizeLine;j++){
                    //copy the character
                    if(!this->map.setTile(temp->getValue(j),j,i)){
                        break;
                    }
                }
            }
        }
        return true;
    }
    return false;
}
//test if have the ID
bool edk::fonts::FontMap::haveID(edk::uint32 ID){
    edk::uint32 width=this->map.getMapSize().width;
    if(width){
        //test the y
        if((ID/width)<this->map.getMapSize().height){
            return true;
        }
    }
    return false;
}
//get position of the tile
edk::vec2ui32 edk::fonts::FontMap::getCharacterPosition(edk::uint32 ID){
    edk::vec2ui32 ret;
    edk::uint32 width=this->map.getMapSize().width;
    edk::uint32 height=this->map.getMapSize().height;
    //test the width
    if(width){
        //get the position
        edk::uint32 x=ID%width;
        edk::uint32 y=ID/width;
        //test the y
        if(y<height){
            ret.x = x;
            ret.y = y;
        }
    }
    return ret;
}
edk::uint32 edk::fonts::FontMap::getCharacterID(edk::vec2ui32 position){
    //test the position
    edk::uint32 width=this->map.getMapSize().width;
    edk::uint32 height=this->map.getMapSize().height;
    if(position.x<=width && position.y<=height){
        //return the ID
        return position.x + (width * position.y);
    }
    return 0u;
}

void edk::fonts::FontMap::draw(edk::vec2ui32 origin,edk::vec2ui32 last,edk::color4f32 color){
    //test if the line is the same
    if(origin.y == last.y){
        //then draw correctly
        this->map.draw(origin,edk::size2ui32(last.x+1u,last.y+1u),color);
    }
    else{
        edk::uint32 width = this->map.getMapSize().width;
        this->map.draw(edk::vec2ui32(origin.x,origin.y),edk::size2ui32(width,origin.y+1u),color);
        //draw all the lines
        for(edk::uint32 i=origin.y+1u;i<last.y;i++){
            this->map.draw(edk::vec2ui32(0u,i),edk::size2ui32(this->map.getMapSize().width,i+1u),color);
        }
        this->map.draw(edk::vec2ui32(0u,last.y),edk::size2ui32(last.x+1u,last.y+1u),color);
    }
}
void edk::fonts::FontMap::draw(edk::uint32 originWidth,edk::uint32 originLine,edk::uint32 lastWidth,edk::uint32 lastLine,edk::color4f32 color){
    this->draw(edk::vec2ui32(originWidth,originLine),edk::vec2ui32 (lastWidth,lastLine),color);
}
void edk::fonts::FontMap::drawWire(edk::vec2ui32 origin,edk::vec2ui32 last,edk::color4f32 color){
    //test if the line is the same
    if(origin.y == last.y){
        //then drawWire correctly
        this->map.drawWire(origin,edk::size2ui32(last.x+1u,last.y+1u),color);
    }
    else{
        edk::uint32 width = this->map.getMapSize().width;
        this->map.drawWire(edk::vec2ui32(origin.x,origin.y),edk::size2ui32(width,origin.y+1u),color);
        //drawWire all the lines
        for(edk::uint32 i=origin.y+1u;i<last.y;i++){
            this->map.drawWire(edk::vec2ui32(0u,i),edk::size2ui32(this->map.getMapSize().width,i+1u),color);
        }
        this->map.drawWire(edk::vec2ui32(0u,last.y),edk::size2ui32(last.x+1u,last.y+1u),color);
    }
}
void edk::fonts::FontMap::drawWire(edk::uint32 originWidth,edk::uint32 originLine,edk::uint32 lastWidth,edk::uint32 lastLine,edk::color4f32 color){
    this->drawWire(edk::vec2ui32(originWidth,originLine),edk::vec2ui32 (lastWidth,lastLine),color);
}
void edk::fonts::FontMap::drawSelection(edk::vec2ui32 origin,edk::vec2ui32 last){
    //test if the line is the same
    if(origin.y == last.y){
        //then drawWire correctly
        this->map.drawSelection(origin,edk::size2ui32(last.x+1u,last.y+1u));
    }
    else{
        edk::uint32 width = this->map.getMapSize().width;
        this->map.drawSelection(edk::vec2ui32(origin.x,origin.y),edk::size2ui32(width,origin.y+1u));
        //drawSelection all the lines
        for(edk::uint32 i=origin.y+1u;i<last.y;i++){
            this->map.drawSelection(edk::vec2ui32(0u,i),edk::size2ui32(this->map.getMapSize().width,i+1u));
        }
        this->map.drawSelection(edk::vec2ui32(0u,last.y),edk::size2ui32(last.x+1u,last.y+1u));
    }
}
void edk::fonts::FontMap::drawSelection(edk::uint32 originWidth,edk::uint32 originLine,edk::uint32 lastWidth,edk::uint32 lastLine){
    this->drawSelection(edk::vec2ui32(originWidth,originLine),edk::vec2ui32 (lastWidth,lastLine));
}
//draw the ID
void edk::fonts::FontMap::draw(edk::uint32 originID,edk::uint32 lastID,edk::color4f32 color){
    edk::vec2ui32 origin = this->getCharacterPosition(originID);
    edk::vec2ui32 last = this->getCharacterPosition(lastID);
    return this->draw(origin,last,color);
}
void edk::fonts::FontMap::draw(edk::vec2ui32 origin,edk::uint32 lastID,edk::color4f32 color){
    edk::vec2ui32 last = this->getCharacterPosition(lastID);
    return this->draw(origin,last,color);
}
void edk::fonts::FontMap::draw(edk::uint32 originID,edk::vec2ui32 last,edk::color4f32 color){
    edk::vec2ui32 origin = this->getCharacterPosition(originID);
    return this->draw(origin,last,color);
}
void edk::fonts::FontMap::drawWire(edk::uint32 originID,edk::uint32 lastID,edk::color4f32 color){
    edk::vec2ui32 origin = this->getCharacterPosition(originID);
    edk::vec2ui32 last = this->getCharacterPosition(lastID);
    return this->drawWire(origin,last,color);
}
void edk::fonts::FontMap::drawWire(edk::vec2ui32 origin,edk::uint32 lastID,edk::color4f32 color){
    edk::vec2ui32 last = this->getCharacterPosition(lastID);
    return this->drawWire(origin,last,color);
}
void edk::fonts::FontMap::drawWire(edk::uint32 originID,edk::vec2ui32 last,edk::color4f32 color){
    edk::vec2ui32 origin = this->getCharacterPosition(originID);
    return this->drawWire(origin,last,color);
}
void edk::fonts::FontMap::drawSelection(edk::uint32 originID,edk::uint32 lastID){
    edk::vec2ui32 origin = this->getCharacterPosition(originID);
    edk::vec2ui32 last = this->getCharacterPosition(lastID);
    return this->drawSelection(origin,last);
}
void edk::fonts::FontMap::drawSelection(edk::vec2ui32 origin,edk::uint32 lastID){
    edk::vec2ui32 last = this->getCharacterPosition(lastID);
    return this->drawSelection(origin,last);
}
void edk::fonts::FontMap::drawSelection(edk::uint32 originID,edk::vec2ui32 last){
    edk::vec2ui32 origin = this->getCharacterPosition(originID);
    return this->drawSelection(origin,last);
}

//SET
void edk::fonts::FontMap::setPosition(edk::vec2f32 position){
    this->map.setPosition(position);
}
void edk::fonts::FontMap::setPosition(edk::float32 x,edk::float32 y){
    this->map.setPosition(x,y);
}
void edk::fonts::FontMap::setScale(edk::size2f32 scale){
    this->map.setScaleMap(scale);
}
void edk::fonts::FontMap::setScale(edk::float32 width,edk::float32 height){
    this->map.setScaleMap(width,height);
}

//GET
edk::vec2f32 edk::fonts::FontMap::getPosition(){
    return this->map.getPosition();
}
edk::float32 edk::fonts::FontMap::getPositionX(){
    return this->map.getPositionX();
}
edk::float32 edk::fonts::FontMap::getPositionY(){
    return this->map.getPositionY();
}
//get size of the map
edk::size2ui32 edk::fonts::FontMap::getMapSize(){
    return this->map.getMapSize();
}
edk::uint32 edk::fonts::FontMap::getMapSizeWidth(){
    return this->map.getMapSize().width;
}
edk::uint32 edk::fonts::FontMap::getMapSizeHeight(){
    return this->map.getMapSize().height;
}
//get the mapScale
edk::size2f32 edk::fonts::FontMap::getMapScale(){
    return this->map.getScaleMap();
}
edk::float32 edk::fonts::FontMap::getMapScaleWidth(){
    return this->map.getScaleMap().width;
}
edk::float32 edk::fonts::FontMap::getMapScaleHeight(){
    return this->map.getScaleMap().height;
}
//return the last position
edk::vec2ui32 edk::fonts::FontMap::getTheLastPosition(){
    vec2ui32 ret(0u,0u);
    if(this->map.getMapSize().width){
        ret.x = this->map.getMapSize().width-1u;
    }
    if(this->map.getMapSize().height){
        ret.y = this->map.getMapSize().height-1u;
    }
    return ret;
}
edk::uint32 edk::fonts::FontMap::getTheLastPositionX(){
    return this->getTheLastPosition().x;
}
edk::uint32 edk::fonts::FontMap::getTheLastPositionY(){
    return this->getTheLastPosition().y;
}
//load fontImage
bool edk::fonts::FontMap::loadFontImage(const char* name,edk::uint32 filter,edk::color4f32 color){
    return this->loadFontImage((edk::char8*) name,filter,color);
}
bool edk::fonts::FontMap::loadFontImage(edk::char8* name,edk::uint32 filter,edk::color4f32 color){
    //remove the fontImage
    this->removeFontImage();
    //test the name
    if(name){
        this->color = color;
        //load the fontImage
        if((this->set = this->list.createFontSet(name,filter,color))){
            //set tileSet in map
            if(this->map.setTileSet(this->set->getTileSet())){
                //return true
                return true;
            }
        }
    }
    //else remove fontImage
    this->removeFontImage();
    return false;
}
bool edk::fonts::FontMap::loadFontImageFromMemory(const char* name,
                                                  edk::uint8* image,
                                                  edk::uint32 size,
                                                  edk::uint32 filter,
                                                  edk::color4f32 color
                                                  ){
    return this->loadFontImageFromMemory((edk::char8*) name,image,size,filter,color);
}

bool edk::fonts::FontMap::loadFontImageFromMemory(edk::char8* name,
                                                  edk::uint8* image,
                                                  edk::uint32 size,
                                                  edk::uint32 filter,
                                                  edk::color4f32 color
                                                  ){
    //remove the fontImage
    this->removeFontImage();
    //test the name
    if(name){
        this->color = color;
        //load the fontImage
        if((this->set = this->list.createFontSetFromMemory(name,image,size,filter,color))){
            //set tileSet in map
            if(this->map.setTileSet(this->set->getTileSet())){
                //return true
                return true;
            }
        }
    }
    //else remove fontImage
    this->removeFontImage();
    return false;
}

//create the string
bool edk::fonts::FontMap::createStringMap(const char* str,edk::uint32 width){
    return this->createStringMap((edk::char8*) str,width);
}
bool edk::fonts::FontMap::createStringMap(edk::char8* str,edk::uint32 width){
    this->cleanLines();
    if(this->addStringLine(str,width)){
        return true;
    }
    //first get the word size
    this->cleanLines();
    return false;
}
bool edk::fonts::FontMap::createStringMap(const char* str){
    return this->createStringMap((edk::char8*) str);
}
bool edk::fonts::FontMap::createStringMap(edk::char8* str){
    this->cleanLines();
    if(this->addStringLine(str)){
        return true;
    }
    this->cleanLines();
    return false;
}
bool edk::fonts::FontMap::addStringLine(const char* str,edk::uint32 width){
    return this->addStringLine((edk::char8*) str, width);
}
bool edk::fonts::FontMap::addStringLine(edk::char8* str,edk::uint32 width){
    //first get the word size
    if(str && width){
        edk::fonts::FontMap::FontLine* line=NULL;
        edk::uint32 size = 0u;
        edk::uint32 c = 0u;
        edk::uint8 jump=0u;
        edk::uint32 enters=0u;
        while(*str){
            //test if dont have the line
            if(!line){
                //create the new line
                line = this->newLine(width);
                this->write=0u;
            }
            //test if have the line
            if(line){
                //
                size = this->wordSize(str);
                if(size){
                    enters=0u;
                    //test if can write the word in the line
                    if(size<=(line->getSize()-this->write)){
                        //then write the word
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(this->write,c+1u);
                            str+=jump;
                            this->write++;
                        }
                    }
                    //test if the write is zero
                    else if(!this->write){
                        //then break the word
                        size = line->getSize();
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(this->write,c+1u);
                            str+=jump;
                            this->write++;
                        }
                    }
                    else{
                        //else create a new line
                        line=NULL;
                    }
                }
                else{
                    //test if can write the character
                    if(this->write<line->getSize()){
                        //write the character
                        c = this->getTileID(str,&jump);
                        //test if have the enter '\n'
                        if(c==10 || c == 13 || c == '\n'){
                            //then create a new line
                            if(enters){
                                line=NULL;
                            }
                            enters++;
                            str+=jump;
                        }
                        else{
                            line->setValue(this->write,c+1u);
                            this->write++;
                            str+=jump;
                            enters=0u;
                        }
                    }
                    else{
                        //else clean the line pointer
                        line=NULL;
                    }
                }
            }
            else{
                return false;
            }
        }
        //test if have lines
        if(this->lines.size()){
            //create the new tileMap
            if(this->map.newTileMap(width,this->lines.size())){
                this->copyLinesToMap();
                //this->cleanLines();
                this->selectAll();
                return true;
            }
        }
    }
    return false;
}
bool edk::fonts::FontMap::addStringLine(const char* str){
    return this->addStringLine((edk::char8*) str);
}
bool edk::fonts::FontMap::addStringLine(edk::char8* str){
    //first get the word size
    if(str){
        edk::fonts::FontMap::FontLine* line=NULL;
        edk::uint32 size = 0u;
        edk::uint32 c = 0u;
        edk::uint8 jump=0u;
        edk::uint32 width=0u;
        edk::uint32 enters=0u;
        while(*str){
            //test if dont have the line
            if(!line){
                //get the lineSize
                width = this->lineSize(str);
                if(width){
                    //create the new line
                    line = this->newLine(width);
                    this->write=0u;
                    enters=0u;
                }
                else{
                    if(*str == 10 || *str == 13){
                        if(enters){
                            this->newLine(1u);
                        }
                        enters++;
                    }
                }
            }
            //test if have the line
            if(line){
                //
                size = this->wordSize(str);
                if(size){
                    //test if can write the word in the line
                    if(size<=(line->getSize()-this->write)){
                        //then write the word
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(this->write,c+1u);
                            str+=jump;
                            this->write++;
                        }
                    }
                    //test if the write is zero
                    else if(!write){
                        //then break the word
                        size = line->getSize();
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(this->write,c+1u);
                            str+=jump;
                            this->write++;
                        }
                    }
                    else{
                        //else create a new line
                        line=NULL;
                    }
                }
                else{
                    //test if can write the character
                    if(this->write<line->getSize()){
                        //write the character
                        c = this->getTileID(str,&jump);
                        //test if have the enter '\n'
                        if(c==10 || c == 13 || c == '\n'){
                            //then create a new line
                            line=NULL;
                            str+=jump;
                        }
                        else{
                            line->setValue(this->write,c+1u);
                            this->write++;
                            str+=jump;
                        }
                    }
                    else{
                        //else clean the line pointer
                        line=NULL;
                    }
                }
            }
            else if(*str)str++;
        }
        //test if have lines
        if(this->lines.size()){
            //create the new tileMap
            if(this->map.newTileMap(this->maxSizeLine,this->lines.size())){
                this->copyLinesToMap();
                //this->cleanLines();
                this->selectAll();
                return true;
            }
        }
    }
    return false;
}
bool edk::fonts::FontMap::createStringMapOneLine(const char* str,edk::uint32 width){
    return this->createStringMapOneLine((edk::char8*) str,width);
}
bool edk::fonts::FontMap::createStringMapOneLine(edk::char8* str,edk::uint32 width){
    this->cleanLines();
    //first get the word size
    if(str && width){
        edk::fonts::FontMap::FontLine* line=NULL;
        edk::uint32 size = 0u;
        edk::uint32 c = 0u;
        edk::uint8 jump=0u;
        edk::uint32 enters=0u;
        bool haveLine = false;
        while(*str){
            //test if dont have the line
            if(!line){
                if(haveLine){
                    break;
                }
                haveLine=true;
                //create the new line
                line = this->newLine(width);
                this->write=0u;
            }
            //test if have the line
            if(line){
                //
                size = this->wordSize(str);
                if(size){
                    enters=0u;
                    //test if can write the word in the line
                    if(size<=(line->getSize()-this->write)){
                        //then write the word
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(this->write,c+1u);
                            str+=jump;
                            this->write++;
                        }
                    }
                    //test if the write is zero
                    else if(!this->write){
                        //then break the word
                        size = line->getSize();
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(this->write,c+1u);
                            str+=jump;
                            this->write++;
                        }
                    }
                    else{
                        //else create a new line
                        line=NULL;
                    }
                }
                else{
                    //test if can write the character
                    if(this->write<line->getSize()){
                        //write the character
                        c = this->getTileID(str,&jump);
                        //test if have the enter '\n'
                        if(c==10 || c == 13 || c == '\n'){
                            //then create a new line
                            if(enters){
                                line=NULL;
                            }
                            enters++;
                            str+=jump;
                        }
                        else{
                            line->setValue(this->write,c+1u);
                            this->write++;
                            str+=jump;
                            enters=0u;
                        }
                    }
                    else{
                        //else clean the line pointer
                        line=NULL;
                    }
                }
            }
            else{
                this->cleanLines();
                return false;
            }
        }
        //test if have lines
        if(this->lines.size()){
            //create the new tileMap
            if(this->map.newTileMap(width,this->lines.size())){
                this->copyLinesToMap();
                //this->cleanLines();
                this->selectAll();
                return true;
            }
        }
    }
    this->cleanLines();
    return false;
}
bool edk::fonts::FontMap::createStringMapOneLine(const char* str){
    return this->createStringMapOneLine((edk::char8*) str);
}
bool edk::fonts::FontMap::createStringMapOneLine(edk::char8* str){
    this->cleanLines();
    //first get the word size
    if(str){
        edk::fonts::FontMap::FontLine* line=NULL;
        edk::uint32 size = 0u;
        edk::uint32 c = 0u;
        edk::uint8 jump=0u;
        edk::uint32 width=0u;
        edk::uint32 enters=0u;
        bool haveLine = false;
        while(*str){
            //test if dont have the line
            if(!line){
                if(haveLine){
                    break;
                }
                haveLine=true;
                //get the lineSize
                width = this->lineSize(str);
                if(width){
                    //create the new line
                    line = this->newLine(width);
                    this->write=0u;
                    enters=0u;
                }
                else{
                    if(*str == 10 || *str == 13){
                        if(enters){
                            this->newLine(1u);
                        }
                        enters++;
                    }
                }
            }
            //test if have the line
            if(line){
                //
                size = this->wordSize(str);
                if(size){
                    //test if can write the word in the line
                    if(size<=(line->getSize()-this->write)){
                        //then write the word
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(this->write,c+1u);
                            str+=jump;
                            this->write++;
                        }
                    }
                    //test if the write is zero
                    else if(!this->write){
                        //then break the word
                        size = line->getSize();
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(this->write,c+1u);
                            str+=jump;
                            this->write++;
                        }
                    }
                    else{
                        //else create a new line
                        line=NULL;
                    }
                }
                else{
                    //test if can write the character
                    if(this->write<line->getSize()){
                        //write the character
                        c = this->getTileID(str,&jump);
                        //test if have the enter '\n'
                        if(c==10 || c == 13 || c == '\n'){
                            //then create a new line
                            line=NULL;
                            str+=jump;
                        }
                        else{
                            line->setValue(this->write,c+1u);
                            this->write++;
                            str+=jump;
                        }
                    }
                    else{
                        //else clean the line pointer
                        line=NULL;
                    }
                }
            }
            else if(*str)str++;
        }
        //test if have lines
        if(this->lines.size()){
            //create the new tileMap
            if(this->map.newTileMap(this->maxSizeLine,this->lines.size())){
                this->copyLinesToMap();
                this->cleanLines();
                this->selectAll();
                return true;
            }
        }
    }
    this->cleanLines();
    return false;
}

//set the color
void edk::fonts::FontMap::setColor(edk::color4f32 color){
    this->color = color;
}
void edk::fonts::FontMap::setColor(edk::float32 r,edk::float32 g,edk::float32 b,edk::float32 a){
    this->setColor(edk::color4f32(r,g,b,a));
}
void edk::fonts::FontMap::setAlpha(edk::float32 value){
    this->color.a = value;
}
void edk::fonts::FontMap::setColor(edk::color4ui8 color){
    this->color = color;
}
void edk::fonts::FontMap::setColor(edk::uint8 r,edk::uint8 g,edk::uint8 b,edk::uint8 a){
    this->setColor(edk::color4ui8(r,g,b,a));
}
void edk::fonts::FontMap::setAlpha(edk::uint8 value){
    this->color.a = (edk::float32)value / 255.f;
}

//delete tileMap
void edk::fonts::FontMap::deleteMap(){
    //delete lines
    //this->cleanLines();
    this->map.deleteTileMap();
}
//return true if have a text
bool edk::fonts::FontMap::haveText(){
    return this->map.haveTileMap();
}

//add callback
bool edk::fonts::FontMap::addCallback(edk::fonts::FontCallback* callback){
    return this->treeCallbacks.add(callback);
}

bool edk::fonts::FontMap::removeCallback(edk::fonts::FontCallback* callback){
    return this->treeCallbacks.remove(callback);
}

//cleanCallacks
void edk::fonts::FontMap::cleanCallbacks(){
    this->treeCallbacks.clean();
}

//Select characters to draw
void edk::fonts::FontMap::selectAll(){
    this->origin = edk::vec2ui32(0u,0u);
    this->last = edk::vec2ui32(this->map.getMapSize().width-1u,this->map.getMapSize().height-1u);
    this->originID = 0u;
    this->lastID = this->getCharacterID(this->last);
}

//set the origin and the last values
bool edk::fonts::FontMap::setOriginAndLast(edk::uint32 originID, edk::uint32 lastID){
    //test if have the ID
    if(this->haveID(originID) && this->haveID(lastID)){
        //test if the ID from origin is smaller than last
        if(originID<lastID){
            //add the interpolation
            this->originID = originID;
            this->lastID = lastID;
            this->origin = this->getCharacterPosition(this->originID);
            this->last = this->getCharacterPosition(this->lastID);
            return true;
        }
    }
    return false;
}
bool edk::fonts::FontMap::setOriginAndLast(edk::vec2ui32 origin, edk::vec2ui32 last){
    return this->setOriginAndLast(this->getCharacterID(origin),this->getCharacterID(last));
}
bool edk::fonts::FontMap::setOriginAndLast(edk::uint32 originX,edk::uint32 originY,edk::uint32 lastX,edk::uint32 lastY){
    return this->setOriginAndLast(edk::vec2ui32(originX,originY),edk::vec2ui32(lastX,lastY));
}
bool edk::fonts::FontMap::setOrigin(edk::uint32 originID){
    //test if have the ID
    if(this->haveID(originID)){
        //test if the ID from origin is smaller than last
        if(originID<this->lastID){
            //add the interpolation
            this->originID = originID;
            this->origin = this->getCharacterPosition(this->originID);
            return true;
        }
    }
    return false;
}
bool edk::fonts::FontMap::setOrigin(edk::vec2ui32 origin){
    return this->setOrigin(this->getCharacterID(origin));
}
bool edk::fonts::FontMap::setOrigin(edk::uint32 originX,edk::uint32 originY){
    return this->setOrigin(edk::vec2ui32(originX,originY));
}
bool edk::fonts::FontMap::setLast(edk::uint32 lastID){
    //test if have the ID
    if(this->haveID(lastID)){
        //test if the ID from origin is smaller than last
        if(lastID>this->originID){
            //add the interpolation
            this->lastID = lastID;
            this->last = this->getCharacterPosition(this->lastID);
            return true;
        }
    }
    return false;
}
bool edk::fonts::FontMap::setLast(edk::vec2ui32 last){
    return this->setLast(this->getCharacterID(last));
}
bool edk::fonts::FontMap::setLast(edk::uint32 lastX,edk::uint32 lastY){
    return this->setLast(edk::vec2ui32(lastX,lastY));
}

//add animations
bool edk::fonts::FontMap::addInterpolation(edk::float32 second,edk::uint32 originID,edk::uint32 lastID){
    //test if have the ID
    if(this->haveID(originID) && this->haveID(lastID)){
        //add the interpolation
        this->animOrigin.addNewInterpolationLine(second,(edk::float32)originID);
        this->animLast.addNewInterpolationLine(second,(edk::float32)lastID+1u);
        return true;
    }
    return false;
}
bool edk::fonts::FontMap::addInterpolation(edk::float32 second,edk::vec2ui32 origin,edk::vec2ui32 last){
    return this->addInterpolation(second,this->getCharacterID(origin),this->getCharacterID(last));
}
bool edk::fonts::FontMap::addInterpolation(edk::float32 second,edk::uint32 originX,edk::uint32 originY,edk::uint32 lastX,edk::uint32 lastY){
    return this->addInterpolation(second,edk::vec2ui32(originX,originY),edk::vec2ui32(lastX,lastY));
}

bool edk::fonts::FontMap::addInterpolationOrigin(edk::float32 second,edk::uint32 ID){
    //test if have the ID
    if(this->haveID(ID)){
        //add the interpolation
        this->animOrigin.addNewInterpolationLine(second,(edk::float32)ID);
        return true;
    }
    return false;
}
bool edk::fonts::FontMap::addInterpolationOrigin(edk::float32 second,edk::vec2ui32 origin){
    return this->addInterpolationOrigin(second,this->getCharacterID(origin));
}
bool edk::fonts::FontMap::addInterpolationOrigin(edk::float32 second,edk::uint32 originX,edk::uint32 originY){
    return this->addInterpolationOrigin(second,edk::vec2ui32(originX,originY));
}
bool edk::fonts::FontMap::addInterpolationLast(edk::float32 second,edk::uint32 ID){
    //test if have the ID
    if(this->haveID(ID)){
        //add the interpolation
        this->animLast.addNewInterpolationLine(second,(edk::float32)ID+1u);
        return true;
    }
    return false;
}
bool edk::fonts::FontMap::addInterpolationLast(edk::float32 second,edk::vec2ui32 last){
    return this->addInterpolationLast(second,this->getCharacterID(last));
}
bool edk::fonts::FontMap::addInterpolationLast(edk::float32 second,edk::uint32 lastX,edk::uint32 lastY){
    return this->addInterpolationLast(second,edk::vec2ui32(lastX,lastY));
}

//Set animation speed
void edk::fonts::FontMap::setAnimationSpeedOrigin(edk::float32 speed){
    this->speedOrigin = speed;
}
//set faster
void edk::fonts::FontMap::setAtimationFasterSpeedOrigin(edk::float32 faster){
    this->fasterOrigin = faster;
}
//speed
void edk::fonts::FontMap::setAnimationSpeedLast(edk::float32 speed){
    this->speedLast=speed;
}
//set faster
void edk::fonts::FontMap::setAtimationFasterSpeedLast(edk::float32 faster){
    this->fasterLast=faster;
}

//CONTROLS
//animation controllers
void edk::fonts::FontMap::playForward(){
    this->animOrigin.playForward();
    this->animLast.playForward();
}
void edk::fonts::FontMap::playForwardIn(edk::float32 second){
    this->animOrigin.playForwardIn(second);
    this->animLast.playForwardIn(second);
}
void edk::fonts::FontMap::playRewind(){
    this->animOrigin.playRewind();
    this->animLast.playRewind();
}
void edk::fonts::FontMap::playRewindIn(edk::float32 second){
    this->animOrigin.playRewindIn(second);
    this->animLast.playRewindIn(second);
}
void edk::fonts::FontMap::pause(){
    this->animLast.pause();
    this->animOrigin.pause();
}
void edk::fonts::FontMap::pauseOn(){
    this->animLast.pauseOn();
    this->animOrigin.pauseOn();
}
void edk::fonts::FontMap::pauseOff(){
    this->animLast.pauseOff();
    this->animOrigin.pauseOff();
}
void edk::fonts::FontMap::stop(){
    this->animOrigin.stop();
    this->animLast.stop();
}
//set loop
void edk::fonts::FontMap::setLoop(bool loop){
    this->animOrigin.setLoop(loop);
    this->animLast.setLoop(loop);
}
void edk::fonts::FontMap::loopOn(){
    this->animOrigin.loopOn();
    this->animLast.loopOn();
}
void edk::fonts::FontMap::loopOff(){
    this->animOrigin.loopOff();
    this->animLast.loopOff();
}

//Force speed for the next update
void edk::fonts::FontMap::forceSpeedInOrigin(edk::float32 speed){
    this->forceSpeedOrigin = true;
    this->forceSpeedOriginValue = speed;
}
void edk::fonts::FontMap::forceSpeedInLast(edk::float32 speed){
    this->forceSpeedLast = true;
    this->forceSpeedLastValue = speed;
}
//update animations
bool edk::fonts::FontMap::updateAnimations(){
    bool ret=false;
    edk::uint32 tileID;
    bool success = false;
    //test if is animating
    if(this->animOrigin.isPlaying()){

        //test if need force speed
        if(this->forceSpeedOrigin){
            this->forceSpeedOrigin = false;
            //set the update speed
            this->animOrigin.setSpeed(this->forceSpeedOriginValue);
        }

        this->animOrigin.updateClockAnimation();

        //get the value
        edk::float32 clockX = this->animLast.getClockX(&success);
        if(success){
            this->originID = (edk::uint32)clockX;
            //update the origin
            this->origin = this->getCharacterPosition(this->originID);

            tileID = this->map.getTileID(this->origin);
            if(tileID == 0u || tileID == ' '){
                //test if found enter
                if(tileID == 0u){
                    //found enter
                    if(!this->enterOrigin){
                        this->enterOrigin=true;
                        //Run found Enter
                        edk::uint32 size = this->treeCallbacks.size();
                        for(edk::uint32 i=0u;i<size;i++){
                            this->treeCallbacks.getElementInPosition(i)->originFoundEnd();
                        }
                    }
                }
                else{
                    this->enterOrigin=false;
                }
                //speed the animation
                this->animOrigin.setSpeed(this->fasterOrigin);//faster
            }
            else{
                this->animOrigin.setSpeed(this->speedOrigin);//normal
                this->enterOrigin=false;
            }

            ret=true;
        }
    }
    if(this->animLast.isPlaying()){

        //test if need force speed
        if(this->forceSpeedLast){
            this->forceSpeedLast = false;
            //set the update speed
            this->animLast.setSpeed(this->forceSpeedLastValue);
        }

        //test the character
        this->animLast.updateClockAnimation();
        //get the value
        edk::float32 clockX = this->animLast.getClockX(&success);
        if(success){
            this->lastID = (edk::uint32)clockX;
            //update last
            this->last = this->getCharacterPosition(this->lastID);

            //update the last speed
            tileID = this->map.getTileID(this->last);
            if(tileID == 0u || tileID == ' '){
                //test if found enter
                if(tileID == 0u){
                    //found enter
                    if(!this->enterOrigin){
                        this->enterOrigin=true;
                        //Run found Enter
                        edk::uint32 size = this->treeCallbacks.size();
                        for(edk::uint32 i=0u;i<size;i++){
                            this->treeCallbacks.getElementInPosition(i)->lastFoundEnd();
                        }
                    }
                }
                else{
                    this->enterOrigin=false;
                }
                //speed the animation
                this->animLast.setSpeed(this->fasterLast);//faster
            }
            else{
                this->animLast.setSpeed(this->speedLast);//normal
                this->enterOrigin=false;
            }

            ret=true;
        }
    }

    //update the position
    if(this->animationPosition.isPlaying()){
        this->animationPosition.updateClockAnimation();
        edk::vec2f32 posTemp;
        posTemp.x = this->animationPosition.getClockX(&success);
        if(success){
            posTemp.y = this->animationPosition.getClockY(&success);
            if(success){
                this->setPosition(posTemp);
            }
        }
    }

    //update the position
    if(this->animationSize.isPlaying()){
        this->animationSize.updateClockAnimation();
        edk::size2f32 sizeTemp;
        sizeTemp.width = this->animationSize.getClockX(&success);
        if(success){
            sizeTemp.height = this->animationSize.getClockY(&success);
            if(success){
                this->setScale(sizeTemp);
            }
        }
    }

    return ret;
}

//draw the text
void edk::fonts::FontMap::draw(edk::color4f32 color){
    this->color = color;
    //this->map.draw(color);
    this->draw(this->origin,this->last,color);
}
void edk::fonts::FontMap::draw(edk::float32 r,edk::float32 g,edk::float32 b,edk::float32 a){
    this->color = edk::color4f32(r,g,b,a);
    //this->map.draw(color);
    this->draw(this->origin,this->last,color);
}
void edk::fonts::FontMap::draw(edk::float32 r,edk::float32 g,edk::float32 b){
    this->draw(r,g,b,1.f);
}
void edk::fonts::FontMap::draw(){
    this->draw(this->origin,this->last,this->color);
}
void edk::fonts::FontMap::drawWire(edk::color4f32 color){
    this->color = color;
    //this->map.drawWire(color);
    this->drawWire(this->origin,this->last,color);
}
void edk::fonts::FontMap::drawWire(edk::float32 r,edk::float32 g,edk::float32 b,edk::float32 a){
    this->color = edk::color4f32(r,g,b,a);
    //this->map.drawWire(color);
    this->drawWire(this->origin,this->last,color);
}
void edk::fonts::FontMap::drawWire(edk::float32 r,edk::float32 g,edk::float32 b){
    this->drawWire(r,g,b,1.f);
}
void edk::fonts::FontMap::drawWire(){
    this->drawWire(this->origin,this->last,this->color);
}
void edk::fonts::FontMap::drawSelection(){
    this->drawSelection(this->origin,this->last);
}
//draw the pivo
void edk::fonts::FontMap::drawPivo(edk::float32 size,edk::color3f32 color){
    this->map.drawPivo(size,color);
}

//remove the fontImage
void edk::fonts::FontMap::removeFontImage(){
    //remove the tileSet from map
    this->map.removeTileSet();
    this->list.removeFontSet(this->set);
    this->set=NULL;
}

void edk::fonts::FontMap::animationEnd(edk::animation::InterpolationGroup* animation){
    //run the animation callback
    edk::uint32 size = this->treeCallbacks.size();
    bool isOrigin=false;
    if(animation == &this->animOrigin) isOrigin=true;
    for(edk::uint32 i=0u;i<size;i++){
        this->treeCallbacks.getElementInPosition(i)->animationEnd(this,isOrigin);
    }
}
