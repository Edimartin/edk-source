#include "FontMap.h"



edk::uint32 EDKFontTemplateSize = 4045u;
edk::char8 EDKFontTemplateName[20] = "EDKFontTemplate.png";
edk::uchar8 EDKFontTemplate[4045] = {
    137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,128,0,0 \
    ,1,0,8,6,0,0,0,123,249,126,167,0,0,0,6,98,75,71,68,0,255 \
    ,0,255,0,255,160,189,167,147,0,0,0,9,112,72,89,115,0,0,11,19,0 \
    ,0,11,19,1,0,154,156,24,0,0,0,7,116,73,77,69,7,227,9,16,11 \
    ,44,56,28,107,202,179,0,0,15,90,73,68,65,84,120,218,237,93,219,178,227 \
    ,170,14,68,46,255,255,47,235,60,205,62,43,9,160,214,13,99,91,170,154,90 \
    ,147,56,198,88,106,132,110,0,49,115,43,122,47,29,197,130,119,211,9,254,110 \
    ,164,38,8,188,94,212,231,19,129,215,172,242,17,219,57,193,198,201,240,96,233 \
    ,94,15,3,239,10,44,26,240,140,59,3,202,194,59,18,100,243,195,191,195,136 \
    ,50,22,30,78,157,123,185,243,127,13,160,88,1,188,221,53,0,37,182,207,26 \
    ,254,28,70,116,145,66,64,12,10,145,29,194,229,78,219,59,125,246,10,31,105 \
    ,255,95,219,212,209,4,35,109,192,4,120,1,158,41,0,5,21,131,215,208,239 \
    ,70,90,232,170,235,232,189,52,1,11,210,62,1,109,126,220,175,1,0,11,243 \
    ,25,25,192,65,128,1,195,32,96,238,48,255,207,52,1,43,13,236,30,143,36 \
    ,27,224,167,205,83,249,2,44,76,1,22,1,17,96,83,88,180,200,46,26,128 \
    ,157,252,69,223,15,225,15,123,52,128,117,10,64,5,204,192,203,73,163,135,54 \
    ,252,108,81,239,45,232,249,51,128,177,86,3,68,186,63,52,249,13,25,219,223 \
    ,249,179,119,122,32,165,187,135,244,133,80,0,80,80,32,8,17,48,41,220,192 \
    ,187,196,2,104,164,126,23,218,29,227,31,84,46,224,246,228,138,45,156,197,191 \
    ,219,147,75,155,84,50,232,229,84,0,40,0,20,189,153,78,135,69,189,210,18 \
    ,247,4,138,138,0,35,80,43,76,41,155,103,13,212,160,198,142,53,93,42,89 \
    ,204,222,235,183,158,2,56,72,248,154,182,70,76,149,66,161,228,16,254,168,127 \
    ,79,72,55,187,109,0,14,16,126,6,19,71,241,108,143,198,226,133,253,95,29 \
    ,19,104,29,109,217,251,215,53,2,45,197,26,212,25,181,153,149,64,108,0,16 \
    ,57,62,107,250,201,192,247,22,32,163,128,101,143,6,232,117,144,147,71,3,129 \
    ,192,35,39,8,86,144,148,185,227,54,46,255,242,104,48,212,118,250,249,254,4 \
    ,110,90,193,240,59,231,249,89,240,146,44,26,21,29,249,163,103,192,6,242,169 \
    ,68,12,250,50,145,214,50,125,89,253,154,233,128,22,245,207,162,177,60,5,31 \
    ,218,254,15,179,177,135,210,183,38,197,247,145,115,44,57,5,71,138,119,65,230 \
    ,118,110,96,213,109,231,251,25,40,127,140,52,160,255,46,13,115,26,24,50,43 \
    ,240,176,198,1,44,158,0,25,53,73,115,222,107,1,21,1,83,172,6,196,214 \
    ,154,137,31,190,157,129,12,201,10,144,244,84,170,22,4,17,83,128,7,64,43 \
    ,12,79,211,111,239,82,15,80,161,224,36,186,75,61,64,9,59,137,42,27,88 \
    ,0,40,42,0,236,53,215,87,145,226,13,1,16,17,235,46,112,221,192,8,204 \
    ,114,131,204,161,204,65,27,20,208,23,90,244,238,183,209,0,158,124,249,44,185 \
    ,244,29,37,179,228,5,188,217,66,68,200,119,206,87,164,79,1,222,80,235,236 \
    ,94,41,236,26,165,185,144,223,60,9,4,28,109,4,210,68,128,22,45,130,174 \
    ,18,234,9,166,23,122,165,100,102,162,185,2,222,69,248,90,0,88,99,209,82 \
    ,169,215,119,140,191,151,8,65,215,194,255,251,126,53,163,103,249,254,45,71,126 \
    ,83,172,13,92,201,192,239,145,130,24,98,60,16,252,149,21,203,189,126,89,13 \
    ,74,243,6,80,200,52,119,167,165,97,232,28,205,23,129,151,1,205,231,201,130 \
    ,166,240,239,48,188,108,84,53,174,166,134,237,78,106,213,99,40,102,77,93,67 \
    ,254,29,11,58,72,192,255,89,217,249,12,70,145,177,47,189,129,65,19,207,104 \
    ,165,49,42,14,158,29,66,193,61,35,80,99,116,142,10,69,56,24,4,119,14 \
    ,4,13,251,188,91,61,192,35,163,109,59,191,123,237,15,112,131,81,250,38,0 \
    ,84,225,199,98,170,122,128,2,64,81,1,160,232,181,116,78,124,113,82,88,170 \
    ,82,213,174,166,170,215,178,242,231,251,119,104,140,129,18,250,191,179,135,241,211 \
    ,255,115,194,116,6,25,57,11,212,16,112,189,41,133,101,117,161,164,12,101,68 \
    ,255,175,114,9,89,57,104,255,235,255,209,176,253,105,53,75,195,181,215,17,225 \
    ,123,152,69,109,109,98,136,29,215,173,241,0,115,240,235,76,120,128,229,5,102 \
    ,153,179,55,145,102,138,237,13,218,158,102,154,102,84,207,0,225,105,85,209,8 \
    ,84,164,212,16,218,221,188,71,125,28,213,15,72,215,45,113,12,235,52,166,93 \
    ,183,201,232,116,112,46,64,111,3,231,208,81,97,40,77,84,41,41,218,159,205 \
    ,135,210,253,150,179,16,50,231,124,15,8,166,83,0,93,240,2,171,170,111,119 \
    ,206,51,160,35,23,209,12,170,247,60,31,206,216,93,230,112,84,205,143,64,64 \
    ,65,207,239,214,3,16,232,26,89,173,97,111,238,126,183,5,29,153,128,247,22 \
    ,147,32,118,198,71,219,127,211,193,154,67,143,26,104,181,163,129,22,212,80,244 \
    ,4,106,52,6,170,212,62,37,3,135,131,71,254,240,119,117,94,192,203,169,114 \
    ,1,5,128,162,2,64,81,1,160,168,0,80,244,66,178,236,15,96,73,84,68 \
    ,187,120,90,55,20,121,190,102,253,161,198,141,101,225,153,218,115,133,53,110,187 \
    ,200,227,227,43,64,48,59,126,156,129,7,143,86,198,204,86,206,32,103,3,244 \
    ,218,71,175,75,207,71,9,89,167,48,91,252,234,105,119,196,79,100,32,78,247 \
    ,95,56,26,182,65,131,103,3,6,207,66,143,6,106,151,166,24,13,200,253,187 \
    ,18,82,111,16,110,3,100,109,215,158,149,120,98,3,72,86,11,49,243,249,42 \
    ,185,156,94,4,77,238,167,11,94,142,87,49,238,2,225,19,96,59,164,85,4 \
    ,161,12,242,110,232,172,97,130,229,58,178,132,123,21,24,50,180,166,26,4,218 \
    ,29,66,86,214,215,69,204,255,163,119,88,57,47,107,237,155,108,254,192,0,200 \
    ,22,52,95,124,255,213,0,230,29,222,239,88,48,202,9,116,99,52,243,36,39 \
    ,48,124,55,107,127,89,32,72,42,138,212,116,118,230,191,179,16,20,65,2,48 \
    ,200,241,111,82,181,141,213,96,26,61,103,246,110,218,145,206,73,26,103,40,223 \
    ,170,7,120,57,85,46,160,0,80,84,0,40,42,0,20,61,130,184,0,80,194 \
    ,87,231,2,144,124,62,27,252,107,239,253,72,123,200,89,133,109,209,117,109,28 \
    ,130,156,163,91,218,46,151,80,13,32,229,243,165,116,177,247,254,81,220,224,110 \
    ,68,13,11,164,81,179,229,29,144,90,7,245,192,58,54,98,94,115,142,16,239 \
    ,179,61,43,163,188,235,27,57,0,120,8,88,46,1,192,168,202,7,169,152,185 \
    ,2,4,200,136,226,9,163,173,41,223,75,34,114,71,167,19,158,156,181,180,213 \
    ,235,206,7,55,205,166,32,244,60,0,239,110,224,124,53,0,188,201,32,116,238 \
    ,187,10,4,30,0,74,54,74,212,18,121,190,18,0,89,42,223,99,253,95,225 \
    ,67,91,19,69,145,231,36,109,9,128,157,246,192,215,26,113,51,1,123,170,134 \
    ,181,171,142,183,2,193,225,28,41,187,205,223,51,35,174,103,180,81,195,203,211 \
    ,87,241,105,169,11,124,0,170,79,242,219,89,41,28,36,112,195,134,251,179,227 \
    ,8,72,93,2,183,152,173,226,104,149,38,181,212,3,212,150,48,15,162,211,57 \
    ,34,10,4,251,19,71,3,160,132,126,47,162,213,110,96,209,141,232,88,232,174 \
    ,21,109,14,128,162,151,27,129,234,92,242,196,101,139,48,88,104,209,189,154,251 \
    ,44,219,177,161,237,103,175,171,132,52,128,37,15,144,177,136,196,235,154,242,69 \
    ,253,247,180,95,167,134,5,50,156,223,40,204,76,0,88,183,98,159,249,162,154 \
    ,18,43,237,145,45,36,168,87,75,74,55,82,149,91,79,15,159,109,49,51,155 \
    ,110,196,45,98,16,68,35,137,18,164,120,66,91,129,35,221,143,46,29,35,80 \
    ,248,222,26,190,40,59,98,116,47,79,250,171,46,201,59,148,15,214,238,17,32 \
    ,1,74,107,88,73,107,24,189,170,119,213,138,104,111,205,64,88,63,79,67,167 \
    ,175,138,21,84,4,178,226,0,143,48,80,175,28,68,219,0,224,105,103,8,220 \
    ,22,4,135,178,195,44,188,128,84,85,139,92,167,201,212,195,194,148,196,64,255 \
    ,17,15,67,178,198,45,219,228,101,181,175,149,223,7,255,222,184,63,64,70,61 \
    ,3,79,220,180,178,1,54,16,120,37,185,70,234,225,37,26,32,226,200,151,29 \
    ,158,17,78,231,91,128,94,110,106,185,129,69,5,128,162,221,167,128,55,20,154 \
    ,206,146,69,214,68,148,38,217,181,173,6,120,131,53,58,91,85,44,217,23,163 \
    ,248,139,203,5,125,139,17,248,22,3,23,73,168,209,55,0,180,249,228,81,14 \
    ,218,148,143,54,32,26,69,124,230,22,49,232,142,163,180,161,246,249,0,193,247 \
    ,217,193,72,62,89,218,64,193,178,197,12,114,236,75,246,8,242,158,157,76,77 \
    ,62,206,94,106,19,217,94,230,187,61,237,212,243,241,174,71,162,58,154,49,152 \
    ,54,27,29,164,20,148,52,63,147,98,14,111,3,160,68,217,16,211,1,123,36 \
    ,50,116,199,29,66,102,207,247,22,92,220,114,205,228,177,120,148,101,164,66,163 \
    ,84,248,213,27,68,60,22,0,200,54,241,90,85,104,81,225,43,55,136,216,49 \
    ,1,213,45,169,251,151,12,178,28,222,168,41,158,68,171,122,45,94,136,38,144 \
    ,34,85,213,54,165,165,111,241,2,50,2,65,118,245,249,5,0,50,34,254,109 \
    ,244,24,30,84,46,224,197,194,255,14,4,117,35,69,194,60,74,47,18,248,174 \
    ,1,158,144,41,160,232,165,84,185,128,247,77,93,31,26,236,72,122,16,3,157 \
    ,136,106,115,234,230,4,168,251,168,254,121,218,145,120,202,194,119,195,80,240,223 \
    ,41,64,218,6,14,73,55,162,155,38,34,103,221,147,161,109,85,46,220,216,63 \
    ,205,119,154,119,68,147,83,20,169,1,70,110,160,39,146,150,37,32,43,192,180 \
    ,237,102,245,79,115,31,27,65,160,54,204,137,255,175,2,200,219,216,205,172,249 \
    ,167,121,48,218,170,33,209,8,212,76,1,218,72,226,85,199,187,104,86,57,121 \
    ,222,79,234,35,69,9,112,160,193,184,129,71,202,204,52,0,170,158,188,243,225 \
    ,138,235,218,254,72,83,130,230,250,21,239,6,247,239,76,82,65,90,235,58,251 \
    ,122,132,7,176,197,105,223,43,227,0,90,27,64,171,65,86,93,71,71,18,25 \
    ,223,111,23,155,194,4,208,163,233,143,119,191,35,121,42,126,238,244,142,179,74 \
    ,161,238,245,35,137,65,59,230,195,181,101,84,156,120,125,31,166,116,114,1,146 \
    ,149,79,160,218,181,222,159,113,93,59,45,101,123,1,145,215,93,70,224,40,25 \
    ,244,68,53,249,244,56,128,203,8,124,116,202,179,4,46,3,160,152,243,82,170 \
    ,138,160,2,192,61,173,215,162,216,41,96,149,225,103,77,48,33,125,139,62,210 \
    ,21,241,138,34,67,193,17,219,221,35,54,207,199,115,44,85,193,154,142,16,240 \
    ,130,145,249,246,102,0,129,246,89,17,158,8,82,130,78,43,238,137,170,9,244 \
    ,38,79,162,70,99,150,38,64,214,69,32,125,66,219,96,229,59,154,235,9,206 \
    ,230,95,222,140,174,122,141,112,199,8,248,46,250,56,250,217,202,31,114,142,122 \
    ,86,188,19,55,127,74,185,107,3,32,145,61,203,17,40,214,233,65,123,157,131 \
    ,63,175,178,135,70,57,152,89,44,95,234,23,105,237,173,19,28,41,223,8,236 \
    ,33,146,7,6,159,52,130,188,215,239,78,232,1,22,154,145,206,224,231,159,122 \
    ,0,6,64,128,34,186,130,75,177,154,66,235,13,253,29,132,52,179,1,180,174 \
    ,195,108,74,40,138,117,109,45,26,64,101,104,107,15,140,168,209,109,87,241,214 \
    ,124,75,170,109,114,76,132,238,41,241,42,250,21,226,104,31,36,54,240,63,174 \
    ,99,60,15,4,72,249,118,228,183,217,94,192,172,127,150,122,130,150,208,127,36 \
    ,142,17,117,191,202,187,169,197,161,190,249,249,110,239,242,243,94,149,13,124,182 \
    ,240,69,239,172,86,7,207,213,232,19,93,201,86,0,176,89,227,143,164,243,134 \
    ,35,180,220,209,68,0,100,231,221,189,171,142,209,109,224,164,235,116,1,120,35 \
    ,121,146,2,128,43,133,63,27,225,72,38,81,138,76,74,139,39,239,98,252,165 \
    ,5,130,118,16,190,116,94,224,37,129,146,133,134,167,246,122,140,241,115,131,56 \
    ,128,116,124,250,140,97,72,69,210,21,163,214,90,82,150,54,5,104,119,251,36 \
    ,0,173,150,124,60,146,230,68,114,225,150,235,171,152,30,169,45,27,0,170,41 \
    ,216,206,1,250,122,140,70,230,87,169,141,145,96,122,27,54,112,179,229,199,103 \
    ,32,180,184,126,12,244,125,118,93,26,217,17,35,127,38,228,111,254,126,240,246 \
    ,92,57,223,4,248,234,124,225,232,215,104,30,14,30,249,86,225,55,9,4,71 \
    ,179,31,100,244,148,128,205,170,114,120,141,240,71,134,175,100,23,105,74,250,232 \
    ,175,23,112,39,90,1,210,72,47,67,58,5,221,178,193,197,108,170,155,29,217 \
    ,35,86,4,21,229,130,86,10,106,113,179,87,89,145,242,255,31,110,32,18,106 \
    ,69,78,209,66,93,48,139,103,144,233,38,173,94,29,109,113,99,83,166,171,170 \
    ,7,184,46,174,65,206,223,132,80,213,3,92,35,252,104,59,195,29,8,42,218 \
    ,203,128,93,230,141,149,6,120,57,29,130,49,196,192,95,22,62,107,220,43,207 \
    ,245,94,63,178,92,67,41,65,101,121,126,68,251,234,231,30,160,21,62,251,43 \
    ,89,242,69,55,208,0,210,50,229,217,223,136,173,230,139,46,6,64,105,128,210 \
    ,0,165,1,222,72,231,151,160,123,71,201,75,32,104,77,94,58,30,229,59,103 \
    ,251,230,61,55,140,19,251,79,201,237,195,0,32,1,8,179,191,109,32,248,168 \
    ,149,195,148,12,6,203,18,47,175,239,207,73,237,243,29,53,192,149,103,9,144 \
    ,225,126,239,254,66,228,236,63,7,188,63,237,164,1,162,183,138,145,174,207,74 \
    ,207,44,237,163,239,151,85,204,66,30,254,150,23,80,94,64,121,1,5,128,210 \
    ,0,165,1,74,3,148,6,40,13,80,26,160,52,64,105,128,210,0,175,162,19 \
    ,24,189,4,248,207,154,253,122,61,62,173,116,175,103,7,81,169,16,213,187,223 \
    ,177,116,191,119,59,62,211,253,85,17,84,83,64,81,1,160,168,0,80,244,110 \
    ,35,240,105,20,149,110,101,167,87,163,77,134,89,238,183,60,159,159,14,0,74 \
    ,188,159,46,126,126,232,253,167,17,121,236,236,12,39,143,112,86,140,48,237,110 \
    ,99,222,254,83,211,31,248,224,105,95,5,0,10,18,12,37,33,60,186,253,72 \
    ,223,222,162,142,233,226,246,203,8,44,47,160,168,0,80,84,0,40,42,0,20 \
    ,21,0,138,10,0,69,239,162,191,123,4,101,31,15,135,180,159,89,77,20,241 \
    ,124,79,158,222,234,235,179,243,247,165,1,138,10,0,69,5,128,162,2,64,209 \
    ,15,105,206,14,182,26,49,30,131,237,187,253,140,229,219,150,227,217,95,5,128 \
    ,43,24,64,11,251,116,201,73,29,59,185,129,188,72,152,172,16,128,229,58,111 \
    ,0,80,222,96,112,168,220,198,179,217,107,207,181,126,118,100,37,141,84,177,99 \
    ,57,167,39,82,3,208,98,80,148,17,88,84,0,40,42,0,20,21,0,138,10 \
    ,0,69,5,128,162,2,64,17,228,175,214,153,65,165,1,138,94,76,232,218,64 \
    ,237,145,113,189,223,61,157,144,4,18,39,243,71,157,196,210,100,3,165,131,157 \
    ,173,225,207,29,0,164,205,83,204,66,200,35,254,100,157,117,136,108,206,53,204 \
    ,161,156,23,50,247,187,179,158,248,57,122,16,229,95,33,253,189,46,49,113,38 \
    ,96,233,180,238,6,128,99,133,240,187,167,187,159,32,131,212,198,229,164,61,132 \
    ,97,100,24,161,8,179,24,16,114,51,10,24,229,75,239,94,116,163,235,20,35 \
    ,208,139,166,16,111,100,242,162,163,204,162,38,115,40,237,98,214,59,65,61,243 \
    ,212,177,191,237,207,50,167,12,92,239,61,131,53,0,208,140,172,76,68,238,190 \
    ,191,224,136,185,4,8,148,13,192,181,242,80,245,140,99,35,65,237,94,141,67 \
    ,11,4,184,156,63,231,70,163,43,226,229,172,181,124,189,83,78,104,33,176,70 \
    ,211,3,13,236,147,176,62,206,182,136,161,11,133,111,5,68,196,78,163,77,176 \
    ,222,51,70,162,183,18,202,108,152,30,77,191,215,111,150,170,70,231,216,172,42 \
    ,228,217,201,222,4,128,21,209,70,108,120,15,237,182,56,42,35,240,9,185,128 \
    ,218,157,252,1,54,192,10,245,89,20,228,5,20,21,0,138,10,0,215,205,247 \
    ,85,192,80,54,64,170,49,153,109,87,176,210,13,77,237,219,177,241,40,231,11 \
    ,132,191,50,28,253,29,89,28,109,76,157,218,183,35,65,112,158,223,213,185,67 \
    ,99,160,164,133,130,53,5,25,179,78,32,209,168,108,159,221,19,65,228,182,111 \
    ,76,1,221,187,72,237,30,159,45,62,164,25,85,17,147,177,65,213,108,174,221 \
    ,53,158,48,58,202,111,233,20,32,133,74,123,130,227,133,35,255,91,93,34,211 \
    ,202,221,2,72,41,118,17,58,5,104,152,135,36,84,86,90,214,145,163,220,187 \
    ,77,156,84,103,209,251,77,42,80,163,167,0,175,141,96,101,58,41,133,144,153 \
    ,208,26,129,127,75,210,122,1,228,52,240,178,173,251,158,154,140,156,2,8,120 \
    ,191,91,77,45,90,47,32,194,104,91,205,160,29,12,61,106,155,70,49,145,116 \
    ,48,131,47,103,25,241,168,167,240,148,93,187,182,123,143,221,234,1,42,183,191 \
    ,185,13,80,84,0,40,42,0,20,61,134,254,7,162,225,171,11,211,132,14,203 \
    ,0,0,0,0,73,69,78,68,174,66,96,130
    };

edk::fonts::FontMap::FontLine::FontLine(edk::uint32 size){
    this->size = size;
    if(this->size){
        this->line = new edk::uint32[this->size];
        if(line){
            //clean the line
            for(edk::uint32 i=0u;i<this->size;i++){
                this->line[i]=0u;
            }
        }
        else{
            this->size=0u;
        }
    }
}
edk::fonts::FontMap::FontLine::~FontLine(){
    //delete the line
    if(this->line) delete[] this->line;
}
//get the size
edk::uint32 edk::fonts::FontMap::FontLine::getSize(){
    return size;
}
//return true if have the line
bool edk::fonts::FontMap::FontLine::haveLine(){
    if(this->line) return true;
    return false;
}
//set the value
bool edk::fonts::FontMap::FontLine::setValue(edk::uint32 position,edk::uint32 value){
    //test if have the position
    if(this->havePosition(position)){
        //set the value
        this->line[position] = value;
        return true;
    }
    return false;
}
//get the value
edk::uint32 edk::fonts::FontMap::FontLine::getValue(edk::uint32 position){
    if(this->havePosition(position)){
        //return the value
        return this->line[position];
    }
    return 0u;
}
//test if have position
bool edk::fonts::FontMap::FontLine::havePosition(edk::uint32 position){
    if(this->line && position<this->size){
        return true;
    }
    return false;
}


edk::fonts::FontMap::FontMap(){
    this->set = NULL;
    this->map.cleanTiles();
    this->originID = this->lastID = 0u;
    this->origin = this->last = edk::vec2ui32(0u,0u);
    this->speedOrigin = this->fasterOrigin = 1.f;
    this->speedLast = 1.f;
    this->fasterLast = 4.f;
    this->animOrigin.setSpeed(this->speedOrigin);
    this->animLast.setSpeed(this->speedLast);
    this->forceSpeedOrigin = forceSpeedLast = false;
    this->forceSpeedOriginValue = this->forceSpeedLastValue = 1.f;
    this->enterOrigin = this->enterLast = false;

    //set the animation callback
    this->animOrigin.setAnimationCallback(this);
    this->animLast.setAnimationCallback(this);
    this->maxSizeLine=0u;

    //load the templateFont
    this->loadFontImageFromMemory(EDKFontTemplateName,EDKFontTemplate,EDKFontTemplateSize);
}
edk::fonts::FontMap::~FontMap(){
    this->removeFontImage();
    this->cleanLines();
}

//gete the tileID
edk::uint32 edk::fonts::FontMap::getTileID(edk::char8* str,edk::uint8* jump){
    //
    if(str && jump){
        *jump=1u;
        if((edk::uint8)*str==195u){
            *jump+=1u;
            str++;
            switch((edk::uint8)*str){
            case 128u:
                //printf("\nCrase A");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 129u:
                //printf("\nAcento A");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 130u:
                //printf("\nChapeu A");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 131u:
                //printf("\nTio A");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 132u:
                //printf("\nTrema A");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 135u:
                //printf("\nCedilha Maiusculo");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 136u:
                //printf("\nCrase E");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 137u:
                //printf("\nAcento E");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 138u:
                //printf("\nChapeu E");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 139u:
                //printf("\nTrema E");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 140u:
                //printf("\nCrase I");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 141u:
                //printf("\nAcento I");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 142u:
                //printf("\nChapeu I");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 143u:
                //printf("\nTrema I");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 145u:
                //printf("\nTio N");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 146u:
                //printf("\nCrase O");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 147u:
                //printf("\nAcento O");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 148u:
                //printf("\nChapeu O");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 149u:
                //printf("\nTio O");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 150u:
                //printf("\nTrema O");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 153u:
                //printf("\nCrase U");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 154u:
                //printf("\nAcento U");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 155u:
                //printf("\nChapeu U");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 156u:
                //printf("\nTrema U");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 157u:
                //printf("\nAcento Y");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 160u:
                //printf("\nCrase a");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 161u:
                //printf("\nAcento a");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 162u:
                //printf("\nChapeu a");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 163u:
                //printf("\nTio a");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 164u:
                //printf("\nTrema a");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 167u:
                //printf("\nCedilha Minusculo");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 168u:
                //printf("\nCrase e");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 169u:
                //printf("\nAcento e");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 170u:
                //printf("\nChapeu e");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 171u:
                //printf("\nTrema e");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 172u:
                //printf("\nCrase i");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 173u:
                //printf("\nAcento i");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 174u:
                //printf("\nChapeu i");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 175u:
                //printf("\ntrema i");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 177u:
                //printf("\nTio n");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 178u:
                //printf("\nCrase o");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 179u:
                //printf("\nAcento o");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 180u:
                //printf("\nChapeu o");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 181u:
                //printf("\nTio o");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 182u:
                //printf("\nTrema o");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 185u:
                //printf("\nCrase u");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 186u:
                //printf("\nAcento u");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 187u:
                //printf("\nChapeu u");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 188u:
                //printf("\nTrema u");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            case 189u:
                //printf("\nAcento y");fflush(stdout);
                return ((edk::uchar8)*str) + 64u;
            default:
                *jump-=1u;
                str--;
            }
        }
        else if((edk::uint8)*str==225u){
            *jump+=1u;
            str++;
            if((edk::uint8)*str==186u){
                *jump+=1u;
                str++;
                if((edk::uint8)*str==189u){
                    //printf("\nTio e");
                    return 32u;
                }
                *jump-=1u;
                str--;
            }
            *jump-=1u;
            str--;
        }
        else if((edk::uint8)*str==196u){
            *jump+=1u;
            str++;
            if((edk::uint8)*str==169u){
                //printf("\nTio i");
                return 32u;
            }
            *jump-=1u;
            str--;
        }
        else if((edk::uint8)*str==197u){
            *jump+=1u;
            str++;
            if((edk::uint8)*str==169u){
                //printf("\nTio u");
                return 32u;
            }
            *jump-=1u;
            str--;
        }
        return (edk::uchar8)*str;
    }
    return 0u;
}
//return the wordSize
edk::uint32 edk::fonts::FontMap::wordSize(edk::char8* str){
    if(str){
        edk::uint32 size = 0u;
        edk::uint8 jump=0u;
        edk::uint32 c = this->getTileID(str,&jump);
        while(c){
            if(c == ' ' || c==10 || c == 13){
                break;
            }
            size++;
            str+=jump;
            c = this->getTileID(str,&jump);
        }
        return size;
    }
    return 0u;
}
//return the lineSize
edk::uint32 edk::fonts::FontMap::lineSize(edk::char8* str){
    if(str){
        edk::uint32 size = 0u;
        edk::uint8 jump=0u;
        edk::uint32 c = this->getTileID(str,&jump);
        while(c){
            if(c==10 || c == 13){
                break;
            }
            size++;
            str+=jump;
            c = this->getTileID(str,&jump);
        }
        return size;
    }
    return 0u;
}

//clean lines
void edk::fonts::FontMap::cleanLines(){
    edk::uint32 size = this->lines.size();
    edk::fonts::FontMap::FontLine * temp = NULL;
    for(edk::uint32 i=0u;i<size;i++){
        temp = this->lines[i];
        if(temp){
            //
            delete temp;
        }
    }
    this->lines.clean();
    this->maxSizeLine=0u;
}
//create new line
edk::fonts::FontMap::FontLine* edk::fonts::FontMap::newLine(edk::uint32 size){
    //test the size
    if(size){
        //create a new line
        edk::fonts::FontMap::FontLine* line = new edk::fonts::FontMap::FontLine(size);
        if(line){
            //test if the line was created
            if(line->getSize() == size){
                //add the line to the stack
                edk::uint32 sizeTemp = this->lines.size();
                this->lines.pushBack(line);
                if(sizeTemp<this->lines.size()){
                    if(size>this->maxSizeLine) this->maxSizeLine = size;
                    //return the line
                    return line;
                }
            }
            delete line;
        }
    }
    return NULL;
}
//copy the text to the map
bool edk::fonts::FontMap::copyLinesToMap(){
    //test if have lines
    edk::uint32 size=this->lines.size();
    edk::uint32 sizeLine=0u;
    if(size){
        //
        edk::fonts::FontMap::FontLine *temp=NULL;
        for(edk::uint32 i=0u;i<size;i++){
            //load the line
            temp = this->lines[i];
            if(temp){
                sizeLine=temp->getSize();
                for(edk::uint32 j=0u;j<sizeLine;j++){
                    //copy the character
                    if(!this->map.setTile(temp->getValue(j),j,i)){
                        break;
                    }
                }
            }
        }
        return true;
    }
    return false;
}
//test if have the ID
bool edk::fonts::FontMap::haveID(edk::uint32 ID){
    edk::uint32 width=this->map.getMapSize().width;
    if(width){
        //test the y
        if((ID/width)<this->map.getMapSize().height){
            return true;
        }
    }
    return false;
}
//get position of the tile
edk::vec2ui32 edk::fonts::FontMap::getCharacterPosition(edk::uint32 ID){
    edk::vec2ui32 ret;
    edk::uint32 width=this->map.getMapSize().width;
    edk::uint32 height=this->map.getMapSize().height;
    //test the width
    if(width){
        //get the position
        edk::uint32 x=ID%width;
        edk::uint32 y=ID/width;
        //test the y
        if(y<height){
            ret.x = x;
            ret.y = y;
        }
    }
    return ret;
}
edk::uint32 edk::fonts::FontMap::getCharacterID(edk::vec2ui32 position){
    //test the position
    edk::uint32 width=this->map.getMapSize().width;
    edk::uint32 height=this->map.getMapSize().height;
    if(position.x<=width && position.y<=height){
        //return the ID
        return position.x + (width * position.y);
    }
    return 0u;
}

void edk::fonts::FontMap::draw(edk::vec2ui32 origin,edk::vec2ui32 last,edk::color4f32 color){
    //test if the line is the same
    if(origin.y == last.y){
        //then draw correctly
        this->map.draw(origin,edk::size2ui32(last.x+1u,last.y+1u),color);
    }
    else{
        edk::uint32 width = this->map.getMapSize().width;
        this->map.draw(edk::vec2ui32(origin.x,origin.y),edk::size2ui32(width,origin.y+1u),color);
        //draw all the lines
        for(edk::uint32 i=origin.y+1u;i<last.y;i++){
            this->map.draw(edk::vec2ui32(0u,i),edk::size2ui32(this->map.getMapSize().width,i+1u),color);
        }
        this->map.draw(edk::vec2ui32(0u,last.y),edk::size2ui32(last.x+1u,last.y+1u),color);
    }
}
void edk::fonts::FontMap::draw(edk::uint32 originWidth,edk::uint32 originLine,edk::uint32 lastWidth,edk::uint32 lastLine,edk::color4f32 color){
    this->draw(edk::vec2ui32(originWidth,originLine),edk::vec2ui32 (lastWidth,lastLine),color);
}
void edk::fonts::FontMap::drawWire(edk::vec2ui32 origin,edk::vec2ui32 last,edk::color4f32 color){
    //test if the line is the same
    if(origin.y == last.y){
        //then drawWire correctly
        this->map.drawWire(origin,edk::size2ui32(last.x+1u,last.y+1u),color);
    }
    else{
        edk::uint32 width = this->map.getMapSize().width;
        this->map.drawWire(edk::vec2ui32(origin.x,origin.y),edk::size2ui32(width,origin.y+1u),color);
        //drawWire all the lines
        for(edk::uint32 i=origin.y+1u;i<last.y;i++){
            this->map.drawWire(edk::vec2ui32(0u,i),edk::size2ui32(this->map.getMapSize().width,i+1u),color);
        }
        this->map.drawWire(edk::vec2ui32(0u,last.y),edk::size2ui32(last.x+1u,last.y+1u),color);
    }
}
void edk::fonts::FontMap::drawWire(edk::uint32 originWidth,edk::uint32 originLine,edk::uint32 lastWidth,edk::uint32 lastLine,edk::color4f32 color){
    this->drawWire(edk::vec2ui32(originWidth,originLine),edk::vec2ui32 (lastWidth,lastLine),color);
}
void edk::fonts::FontMap::drawSelection(edk::vec2ui32 origin,edk::vec2ui32 last){
    //test if the line is the same
    if(origin.y == last.y){
        //then drawWire correctly
        this->map.drawSelection(origin,edk::size2ui32(last.x+1u,last.y+1u));
    }
    else{
        edk::uint32 width = this->map.getMapSize().width;
        this->map.drawSelection(edk::vec2ui32(origin.x,origin.y),edk::size2ui32(width,origin.y+1u));
        //drawSelection all the lines
        for(edk::uint32 i=origin.y+1u;i<last.y;i++){
            this->map.drawSelection(edk::vec2ui32(0u,i),edk::size2ui32(this->map.getMapSize().width,i+1u));
        }
        this->map.drawSelection(edk::vec2ui32(0u,last.y),edk::size2ui32(last.x+1u,last.y+1u));
    }
}
void edk::fonts::FontMap::drawSelection(edk::uint32 originWidth,edk::uint32 originLine,edk::uint32 lastWidth,edk::uint32 lastLine){
    this->drawSelection(edk::vec2ui32(originWidth,originLine),edk::vec2ui32 (lastWidth,lastLine));
}
//draw the ID
void edk::fonts::FontMap::draw(edk::uint32 originID,edk::uint32 lastID,edk::color4f32 color){
    edk::vec2ui32 origin = this->getCharacterPosition(originID);
    edk::vec2ui32 last = this->getCharacterPosition(lastID);
    return this->draw(origin,last,color);
}
void edk::fonts::FontMap::draw(edk::vec2ui32 origin,edk::uint32 lastID,edk::color4f32 color){
    edk::vec2ui32 last = this->getCharacterPosition(lastID);
    return this->draw(origin,last,color);
}
void edk::fonts::FontMap::draw(edk::uint32 originID,edk::vec2ui32 last,edk::color4f32 color){
    edk::vec2ui32 origin = this->getCharacterPosition(originID);
    return this->draw(origin,last,color);
}
void edk::fonts::FontMap::drawWire(edk::uint32 originID,edk::uint32 lastID,edk::color4f32 color){
    edk::vec2ui32 origin = this->getCharacterPosition(originID);
    edk::vec2ui32 last = this->getCharacterPosition(lastID);
    return this->drawWire(origin,last,color);
}
void edk::fonts::FontMap::drawWire(edk::vec2ui32 origin,edk::uint32 lastID,edk::color4f32 color){
    edk::vec2ui32 last = this->getCharacterPosition(lastID);
    return this->drawWire(origin,last,color);
}
void edk::fonts::FontMap::drawWire(edk::uint32 originID,edk::vec2ui32 last,edk::color4f32 color){
    edk::vec2ui32 origin = this->getCharacterPosition(originID);
    return this->drawWire(origin,last,color);
}
void edk::fonts::FontMap::drawSelection(edk::uint32 originID,edk::uint32 lastID){
    edk::vec2ui32 origin = this->getCharacterPosition(originID);
    edk::vec2ui32 last = this->getCharacterPosition(lastID);
    return this->drawSelection(origin,last);
}
void edk::fonts::FontMap::drawSelection(edk::vec2ui32 origin,edk::uint32 lastID){
    edk::vec2ui32 last = this->getCharacterPosition(lastID);
    return this->drawSelection(origin,last);
}
void edk::fonts::FontMap::drawSelection(edk::uint32 originID,edk::vec2ui32 last){
    edk::vec2ui32 origin = this->getCharacterPosition(originID);
    return this->drawSelection(origin,last);
}

//SET
void edk::fonts::FontMap::setPosition(edk::vec2f32 position){
    this->map.setPosition(position);
}
void edk::fonts::FontMap::setPosition(edk::float32 x,edk::float32 y){
    this->map.setPosition(x,y);
}
void edk::fonts::FontMap::setScale(edk::size2f32 scale){
    this->map.setScaleMap(scale);
}
void edk::fonts::FontMap::setScale(edk::float32 width,edk::float32 height){
    this->map.setScaleMap(width,height);
}

//GET
edk::vec2f32 edk::fonts::FontMap::getPosition(){
    return this->map.getPosition();
}
edk::float32 edk::fonts::FontMap::getPositionX(){
    return this->map.getPositionX();
}
edk::float32 edk::fonts::FontMap::getPositionY(){
    return this->map.getPositionY();
}
//get size of the map
edk::size2ui32 edk::fonts::FontMap::getMapSize(){
    return this->map.getMapSize();
}
edk::uint32 edk::fonts::FontMap::getMapSizeWidth(){
    return this->map.getMapSize().width;
}
edk::uint32 edk::fonts::FontMap::getMapSizeHeight(){
    return this->map.getMapSize().height;
}
//get the mapScale
edk::size2f32 edk::fonts::FontMap::getMapScale(){
    return this->map.getScaleMap();
}
edk::float32 edk::fonts::FontMap::getMapScaleWidth(){
    return this->map.getScaleMap().width;
}
edk::float32 edk::fonts::FontMap::getMapScaleHeight(){
    return this->map.getScaleMap().height;
}
//return the last position
edk::vec2ui32 edk::fonts::FontMap::getTheLastPosition(){
    vec2ui32 ret(0u,0u);
    if(this->map.getMapSize().width){
        ret.x = this->map.getMapSize().width-1u;
    }
    if(this->map.getMapSize().height){
        ret.y = this->map.getMapSize().height-1u;
    }
    return ret;
}
edk::uint32 edk::fonts::FontMap::getTheLastPositionX(){
    return this->getTheLastPosition().x;
}
edk::uint32 edk::fonts::FontMap::getTheLastPositionY(){
    return this->getTheLastPosition().y;
}
//load fontImage
bool edk::fonts::FontMap::loadFontImage(const char* name,edk::uint32 filter,edk::color4f32 color){
    return this->loadFontImage((edk::char8*) name,filter,color);
}
bool edk::fonts::FontMap::loadFontImage(edk::char8* name,edk::uint32 filter,edk::color4f32 color){
    //remove the fontImage
    this->removeFontImage();
    //test the name
    if(name){
        this->color = color;
        //load the fontImage
        if((this->set = this->list.createFontSet(name,filter,color))){
            //set tileSet in map
            if(this->map.setTileSet(this->set->getTileSet())){
                //return true
                return true;
            }
        }
    }
    //else remove fontImage
    this->removeFontImage();
    return false;
}
bool edk::fonts::FontMap::loadFontImageFromMemory(const char* name,
                                                  edk::uint8* image,
                                                  edk::uint32 size,
                                                  edk::uint32 filter,
                                                  edk::color4f32 color
                                                  ){
    return this->loadFontImageFromMemory((edk::char8*) name,image,size,filter,color);
}

bool edk::fonts::FontMap::loadFontImageFromMemory(edk::char8* name,
                                                  edk::uint8* image,
                                                  edk::uint32 size,
                                                  edk::uint32 filter,
                                                  edk::color4f32 color
                                                  ){
    //remove the fontImage
    this->removeFontImage();
    //test the name
    if(name){
        this->color = color;
        //load the fontImage
        if((this->set = this->list.createFontSetFromMemory(name,image,size,filter,color))){
            //set tileSet in map
            if(this->map.setTileSet(this->set->getTileSet())){
                //return true
                return true;
            }
        }
    }
    //else remove fontImage
    this->removeFontImage();
    return false;
}

//create the string
bool edk::fonts::FontMap::createStringMap(const char* str,edk::uint32 width){
    return this->createStringMap((edk::char8*) str,width);
}
bool edk::fonts::FontMap::createStringMap(edk::char8* str,edk::uint32 width){
    this->cleanLines();
    //first get the word size
    if(str && width){
        edk::fonts::FontMap::FontLine* line=NULL;
        edk::uint32 size = 0u;
        edk::uint32 write=0u;
        edk::uint32 c = 0u;
        edk::uint8 jump=0u;
        edk::uint32 enters=0u;
        while(*str){
            //test if dont have the line
            if(!line){
                //create the new line
                line = this->newLine(width);
                write=0u;
            }
            //test if have the line
            if(line){
                //
                size = this->wordSize(str);
                if(size){
                    enters=0u;
                    //test if can write the word in the line
                    if(size<=(line->getSize()-write)){
                        //then write the word
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(write,c+1u);
                            str+=jump;
                            write++;
                        }
                    }
                    //test if the write is zero
                    else if(!write){
                        //then break the word
                        size = line->getSize();
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(write,c+1u);
                            str+=jump;
                            write++;
                        }
                    }
                    else{
                        //else create a new line
                        line=NULL;
                    }
                }
                else{
                    //test if can write the character
                    if(write<line->getSize()){
                        //write the character
                        c = this->getTileID(str,&jump);
                        //test if have the enter '\n'
                        if(c==10 || c == 13 || c == '\n'){
                            //then create a new line
                            if(enters){
                                line=NULL;
                            }
                            enters++;
                            str+=jump;
                        }
                        else{
                            line->setValue(write,c+1u);
                            write++;
                            str+=jump;
                            enters=0u;
                        }
                    }
                    else{
                        //else clean the line pointer
                        line=NULL;
                    }
                }
            }
            else{
                this->cleanLines();
                return false;
            }
        }
        //test if have lines
        if(this->lines.size()){
            //create the new tileMap
            if(this->map.newTileMap(width,this->lines.size())){
                this->copyLinesToMap();
                this->cleanLines();
                this->selectAll();
                return true;
            }
        }
    }
    this->cleanLines();
    return false;
}
bool edk::fonts::FontMap::createStringMap(const char* str){
    return this->createStringMap((edk::char8*) str);
}
bool edk::fonts::FontMap::createStringMap(edk::char8* str){
    this->cleanLines();
    //first get the word size
    if(str){
        edk::fonts::FontMap::FontLine* line=NULL;
        edk::uint32 size = 0u;
        edk::uint32 write=0u;
        edk::uint32 c = 0u;
        edk::uint8 jump=0u;
        edk::uint32 width=0u;
        edk::uint32 enters=0u;
        while(*str){
            //test if dont have the line
            if(!line){
                //get the lineSize
                width = this->lineSize(str);
                if(width){
                    //create the new line
                    line = this->newLine(width);
                    write=0u;
                    enters=0u;
                }
                else{
                    if(*str == 10 || *str == 13){
                        if(enters){
                            this->newLine(1u);
                        }
                        enters++;
                    }
                }
            }
            //test if have the line
            if(line){
                //
                size = this->wordSize(str);
                if(size){
                    //test if can write the word in the line
                    if(size<=(line->getSize()-write)){
                        //then write the word
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(write,c+1u);
                            str+=jump;
                            write++;
                        }
                    }
                    //test if the write is zero
                    else if(!write){
                        //then break the word
                        size = line->getSize();
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(write,c+1u);
                            str+=jump;
                            write++;
                        }
                    }
                    else{
                        //else create a new line
                        line=NULL;
                    }
                }
                else{
                    //test if can write the character
                    if(write<line->getSize()){
                        //write the character
                        c = this->getTileID(str,&jump);
                        //test if have the enter '\n'
                        if(c==10 || c == 13 || c == '\n'){
                            //then create a new line
                            line=NULL;
                            str+=jump;
                        }
                        else{
                            line->setValue(write,c+1u);
                            write++;
                            str+=jump;
                        }
                    }
                    else{
                        //else clean the line pointer
                        line=NULL;
                    }
                }
            }
            else if(*str)str++;
        }
        //test if have lines
        if(this->lines.size()){
            //create the new tileMap
            if(this->map.newTileMap(this->maxSizeLine,this->lines.size())){
                this->copyLinesToMap();
                this->cleanLines();
                this->selectAll();
                return true;
            }
        }
    }
    this->cleanLines();
    return false;
}
bool edk::fonts::FontMap::createStringMapOneLine(const char* str,edk::uint32 width){
    return this->createStringMapOneLine((edk::char8*) str,width);
}
bool edk::fonts::FontMap::createStringMapOneLine(edk::char8* str,edk::uint32 width){
    this->cleanLines();
    //first get the word size
    if(str && width){
        edk::fonts::FontMap::FontLine* line=NULL;
        edk::uint32 size = 0u;
        edk::uint32 write=0u;
        edk::uint32 c = 0u;
        edk::uint8 jump=0u;
        edk::uint32 enters=0u;
        bool haveLine = false;
        while(*str){
            //test if dont have the line
            if(!line){
                if(haveLine){
                    break;
                }
                haveLine=true;
                //create the new line
                line = this->newLine(width);
                write=0u;
            }
            //test if have the line
            if(line){
                //
                size = this->wordSize(str);
                if(size){
                    enters=0u;
                    //test if can write the word in the line
                    if(size<=(line->getSize()-write)){
                        //then write the word
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(write,c+1u);
                            str+=jump;
                            write++;
                        }
                    }
                    //test if the write is zero
                    else if(!write){
                        //then break the word
                        size = line->getSize();
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(write,c+1u);
                            str+=jump;
                            write++;
                        }
                    }
                    else{
                        //else create a new line
                        line=NULL;
                    }
                }
                else{
                    //test if can write the character
                    if(write<line->getSize()){
                        //write the character
                        c = this->getTileID(str,&jump);
                        //test if have the enter '\n'
                        if(c==10 || c == 13 || c == '\n'){
                            //then create a new line
                            if(enters){
                                line=NULL;
                            }
                            enters++;
                            str+=jump;
                        }
                        else{
                            line->setValue(write,c+1u);
                            write++;
                            str+=jump;
                            enters=0u;
                        }
                    }
                    else{
                        //else clean the line pointer
                        line=NULL;
                    }
                }
            }
            else{
                this->cleanLines();
                return false;
            }
        }
        //test if have lines
        if(this->lines.size()){
            //create the new tileMap
            if(this->map.newTileMap(width,this->lines.size())){
                this->copyLinesToMap();
                this->cleanLines();
                this->selectAll();
                return true;
            }
        }
    }
    this->cleanLines();
    return false;
}
bool edk::fonts::FontMap::createStringMapOneLine(const char* str){
    return this->createStringMapOneLine((edk::char8*) str);
}
bool edk::fonts::FontMap::createStringMapOneLine(edk::char8* str){
    this->cleanLines();
    //first get the word size
    if(str){
        edk::fonts::FontMap::FontLine* line=NULL;
        edk::uint32 size = 0u;
        edk::uint32 write=0u;
        edk::uint32 c = 0u;
        edk::uint8 jump=0u;
        edk::uint32 width=0u;
        edk::uint32 enters=0u;
        bool haveLine = false;
        while(*str){
            //test if dont have the line
            if(!line){
                if(haveLine){
                    break;
                }
                haveLine=true;
                //get the lineSize
                width = this->lineSize(str);
                if(width){
                    //create the new line
                    line = this->newLine(width);
                    write=0u;
                    enters=0u;
                }
                else{
                    if(*str == 10 || *str == 13){
                        if(enters){
                            this->newLine(1u);
                        }
                        enters++;
                    }
                }
            }
            //test if have the line
            if(line){
                //
                size = this->wordSize(str);
                if(size){
                    //test if can write the word in the line
                    if(size<=(line->getSize()-write)){
                        //then write the word
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(write,c+1u);
                            str+=jump;
                            write++;
                        }
                    }
                    //test if the write is zero
                    else if(!write){
                        //then break the word
                        size = line->getSize();
                        for(edk::uint32 i=0u;i<size;i++){
                            c = this->getTileID(str,&jump);
                            line->setValue(write,c+1u);
                            str+=jump;
                            write++;
                        }
                    }
                    else{
                        //else create a new line
                        line=NULL;
                    }
                }
                else{
                    //test if can write the character
                    if(write<line->getSize()){
                        //write the character
                        c = this->getTileID(str,&jump);
                        //test if have the enter '\n'
                        if(c==10 || c == 13 || c == '\n'){
                            //then create a new line
                            line=NULL;
                            str+=jump;
                        }
                        else{
                            line->setValue(write,c+1u);
                            write++;
                            str+=jump;
                        }
                    }
                    else{
                        //else clean the line pointer
                        line=NULL;
                    }
                }
            }
            else if(*str)str++;
        }
        //test if have lines
        if(this->lines.size()){
            //create the new tileMap
            if(this->map.newTileMap(this->maxSizeLine,this->lines.size())){
                this->copyLinesToMap();
                this->cleanLines();
                this->selectAll();
                return true;
            }
        }
    }
    this->cleanLines();
    return false;
}

//set the color
void edk::fonts::FontMap::setColor(edk::color4f32 color){
    this->color = color;
}
void edk::fonts::FontMap::setColor(edk::float32 r,edk::float32 g,edk::float32 b,edk::float32 a){
    this->setColor(edk::color4f32(r,g,b,a));
}
void edk::fonts::FontMap::setAlpha(edk::float32 value){
    this->color.a = value;
}
void edk::fonts::FontMap::setColor(edk::color4ui8 color){
    this->color = color;
}
void edk::fonts::FontMap::setColor(edk::uint8 r,edk::uint8 g,edk::uint8 b,edk::uint8 a){
    this->setColor(edk::color4ui8(r,g,b,a));
}
void edk::fonts::FontMap::setAlpha(edk::uint8 value){
    this->color.a = (edk::float32)value / 255.f;
}

//delete tileMap
void edk::fonts::FontMap::deleteMap(){
    //delete lines
    //this->cleanLines();
    this->map.deleteTileMap();
}
//return true if have a text
bool edk::fonts::FontMap::haveText(){
    return this->map.haveTileMap();
}

//add callback
bool edk::fonts::FontMap::addCallback(edk::fonts::FontCallback* callback){
    return this->treeCallbacks.add(callback);
}

bool edk::fonts::FontMap::removeCallback(edk::fonts::FontCallback* callback){
    return this->treeCallbacks.remove(callback);
}

//cleanCallacks
void edk::fonts::FontMap::cleanCallbacks(){
    this->treeCallbacks.clean();
}

//Select characters to draw
void edk::fonts::FontMap::selectAll(){
    this->origin = edk::vec2ui32(0u,0u);
    this->last = edk::vec2ui32(this->map.getMapSize().width-1u,this->map.getMapSize().height-1u);
    this->originID = 0u;
    this->lastID = this->getCharacterID(this->last);
}

//set the origin and the last values
bool edk::fonts::FontMap::setOriginAndLast(edk::uint32 originID, edk::uint32 lastID){
    //test if have the ID
    if(this->haveID(originID) && this->haveID(lastID)){
        //test if the ID from origin is smaller than last
        if(originID<lastID){
            //add the interpolation
            this->originID = originID;
            this->lastID = lastID;
            this->origin = this->getCharacterPosition(this->originID);
            this->last = this->getCharacterPosition(this->lastID);
            return true;
        }
    }
    return false;
}
bool edk::fonts::FontMap::setOriginAndLast(edk::vec2ui32 origin, edk::vec2ui32 last){
    return this->setOriginAndLast(this->getCharacterID(origin),this->getCharacterID(last));
}
bool edk::fonts::FontMap::setOriginAndLast(edk::uint32 originX,edk::uint32 originY,edk::uint32 lastX,edk::uint32 lastY){
    return this->setOriginAndLast(edk::vec2ui32(originX,originY),edk::vec2ui32(lastX,lastY));
}
bool edk::fonts::FontMap::setOrigin(edk::uint32 originID){
    //test if have the ID
    if(this->haveID(originID)){
        //test if the ID from origin is smaller than last
        if(originID<this->lastID){
            //add the interpolation
            this->originID = originID;
            this->origin = this->getCharacterPosition(this->originID);
            return true;
        }
    }
    return false;
}
bool edk::fonts::FontMap::setOrigin(edk::vec2ui32 origin){
    return this->setOrigin(this->getCharacterID(origin));
}
bool edk::fonts::FontMap::setOrigin(edk::uint32 originX,edk::uint32 originY){
    return this->setOrigin(edk::vec2ui32(originX,originY));
}
bool edk::fonts::FontMap::setLast(edk::uint32 lastID){
    //test if have the ID
    if(this->haveID(lastID)){
        //test if the ID from origin is smaller than last
        if(lastID>this->originID){
            //add the interpolation
            this->lastID = lastID;
            this->last = this->getCharacterPosition(this->lastID);
            return true;
        }
    }
    return false;
}
bool edk::fonts::FontMap::setLast(edk::vec2ui32 last){
    return this->setLast(this->getCharacterID(last));
}
bool edk::fonts::FontMap::setLast(edk::uint32 lastX,edk::uint32 lastY){
    return this->setLast(edk::vec2ui32(lastX,lastY));
}

//add animations
bool edk::fonts::FontMap::addInterpolation(edk::float32 second,edk::uint32 originID,edk::uint32 lastID){
    //test if have the ID
    if(this->haveID(originID) && this->haveID(lastID)){
        //add the interpolation
        this->animOrigin.addNewInterpolationLine(second,(edk::float32)originID);
        this->animLast.addNewInterpolationLine(second,(edk::float32)lastID+1u);
        return true;
    }
    return false;
}
bool edk::fonts::FontMap::addInterpolation(edk::float32 second,edk::vec2ui32 origin,edk::vec2ui32 last){
    return this->addInterpolation(second,this->getCharacterID(origin),this->getCharacterID(last));
}
bool edk::fonts::FontMap::addInterpolation(edk::float32 second,edk::uint32 originX,edk::uint32 originY,edk::uint32 lastX,edk::uint32 lastY){
    return this->addInterpolation(second,edk::vec2ui32(originX,originY),edk::vec2ui32(lastX,lastY));
}

bool edk::fonts::FontMap::addInterpolationOrigin(edk::float32 second,edk::uint32 ID){
    //test if have the ID
    if(this->haveID(ID)){
        //add the interpolation
        this->animOrigin.addNewInterpolationLine(second,(edk::float32)ID);
        return true;
    }
    return false;
}
bool edk::fonts::FontMap::addInterpolationOrigin(edk::float32 second,edk::vec2ui32 origin){
    return this->addInterpolationOrigin(second,this->getCharacterID(origin));
}
bool edk::fonts::FontMap::addInterpolationOrigin(edk::float32 second,edk::uint32 originX,edk::uint32 originY){
    return this->addInterpolationOrigin(second,edk::vec2ui32(originX,originY));
}
bool edk::fonts::FontMap::addInterpolationLast(edk::float32 second,edk::uint32 ID){
    //test if have the ID
    if(this->haveID(ID)){
        //add the interpolation
        this->animLast.addNewInterpolationLine(second,(edk::float32)ID+1u);
        return true;
    }
    return false;
}
bool edk::fonts::FontMap::addInterpolationLast(edk::float32 second,edk::vec2ui32 last){
    return this->addInterpolationLast(second,this->getCharacterID(last));
}
bool edk::fonts::FontMap::addInterpolationLast(edk::float32 second,edk::uint32 lastX,edk::uint32 lastY){
    return this->addInterpolationLast(second,edk::vec2ui32(lastX,lastY));
}

//Set animation speed
void edk::fonts::FontMap::setAnimationSpeedOrigin(edk::float32 speed){
    this->speedOrigin = speed;
}
//set faster
void edk::fonts::FontMap::setAtimationFasterSpeedOrigin(edk::float32 faster){
    this->fasterOrigin = faster;
}
//speed
void edk::fonts::FontMap::setAnimationSpeedLast(edk::float32 speed){
    this->speedLast=speed;
}
//set faster
void edk::fonts::FontMap::setAtimationFasterSpeedLast(edk::float32 faster){
    this->fasterLast=faster;
}

//CONTROLS
//animation controllers
void edk::fonts::FontMap::playForward(){
    this->animOrigin.playForward();
    this->animLast.playForward();
}
void edk::fonts::FontMap::playForwardIn(edk::float32 second){
    this->animOrigin.playForwardIn(second);
    this->animLast.playForwardIn(second);
}
void edk::fonts::FontMap::playRewind(){
    this->animOrigin.playRewind();
    this->animLast.playRewind();
}
void edk::fonts::FontMap::playRewindIn(edk::float32 second){
    this->animOrigin.playRewindIn(second);
    this->animLast.playRewindIn(second);
}
void edk::fonts::FontMap::pause(){
    this->animLast.pause();
    this->animOrigin.pause();
}
void edk::fonts::FontMap::pauseOn(){
    this->animLast.pauseOn();
    this->animOrigin.pauseOn();
}
void edk::fonts::FontMap::pauseOff(){
    this->animLast.pauseOff();
    this->animOrigin.pauseOff();
}
void edk::fonts::FontMap::stop(){
    this->animOrigin.stop();
    this->animLast.stop();
}
//set loop
void edk::fonts::FontMap::setLoop(bool loop){
    this->animOrigin.setLoop(loop);
    this->animLast.setLoop(loop);
}
void edk::fonts::FontMap::loopOn(){
    this->animOrigin.loopOn();
    this->animLast.loopOn();
}
void edk::fonts::FontMap::loopOff(){
    this->animOrigin.loopOff();
    this->animLast.loopOff();
}

//Force speed for the next update
void edk::fonts::FontMap::forceSpeedInOrigin(edk::float32 speed){
    this->forceSpeedOrigin = true;
    this->forceSpeedOriginValue = speed;
}
void edk::fonts::FontMap::forceSpeedInLast(edk::float32 speed){
    this->forceSpeedLast = true;
    this->forceSpeedLastValue = speed;
}
//update animations
bool edk::fonts::FontMap::updateAnimations(){
    bool ret=false;
    edk::uint32 tileID;
    bool success = false;
    //test if is animating
    if(this->animOrigin.isPlaying()){

        //test if need force speed
        if(this->forceSpeedOrigin){
            this->forceSpeedOrigin = false;
            //set the update speed
            this->animOrigin.setSpeed(this->forceSpeedOriginValue);
        }

        this->animOrigin.updateClockAnimation();

        //get the value
        edk::float32 clockX = this->animLast.getClockX(&success);
        if(success){
            this->originID = (edk::uint32)clockX;
            //update the origin
            this->origin = this->getCharacterPosition(this->originID);

            tileID = this->map.getTileID(this->origin);
            if(tileID == 0u || tileID == ' '){
                //test if found enter
                if(tileID == 0u){
                    //found enter
                    if(!this->enterOrigin){
                        this->enterOrigin=true;
                        //Run found Enter
                        edk::uint32 size = this->treeCallbacks.size();
                        for(edk::uint32 i=0u;i<size;i++){
                            this->treeCallbacks.getElementInPosition(i)->originFoundEnd();
                        }
                    }
                }
                else{
                    this->enterOrigin=false;
                }
                //speed the animation
                this->animOrigin.setSpeed(this->fasterOrigin);//faster
            }
            else{
                this->animOrigin.setSpeed(this->speedOrigin);//normal
                this->enterOrigin=false;
            }

            ret=true;
        }
    }
    if(this->animLast.isPlaying()){

        //test if need force speed
        if(this->forceSpeedLast){
            this->forceSpeedLast = false;
            //set the update speed
            this->animLast.setSpeed(this->forceSpeedLastValue);
        }

        //test the character
        this->animLast.updateClockAnimation();
        //get the value
        edk::float32 clockX = this->animLast.getClockX(&success);
        if(success){
            this->lastID = (edk::uint32)clockX;
            //update last
            this->last = this->getCharacterPosition(this->lastID);

            //update the last speed
            tileID = this->map.getTileID(this->last);
            if(tileID == 0u || tileID == ' '){
                //test if found enter
                if(tileID == 0u){
                    //found enter
                    if(!this->enterOrigin){
                        this->enterOrigin=true;
                        //Run found Enter
                        edk::uint32 size = this->treeCallbacks.size();
                        for(edk::uint32 i=0u;i<size;i++){
                            this->treeCallbacks.getElementInPosition(i)->lastFoundEnd();
                        }
                    }
                }
                else{
                    this->enterOrigin=false;
                }
                //speed the animation
                this->animLast.setSpeed(this->fasterLast);//faster
            }
            else{
                this->animLast.setSpeed(this->speedLast);//normal
                this->enterOrigin=false;
            }

            ret=true;
        }
    }

    //update the position
    if(this->animationPosition.isPlaying()){
        this->animationPosition.updateClockAnimation();
        edk::vec2f32 posTemp;
        posTemp.x = this->animationPosition.getClockX(&success);
        if(success){
            posTemp.y = this->animationPosition.getClockY(&success);
            if(success){
                this->setPosition(posTemp);
            }
        }
    }

    //update the position
    if(this->animationSize.isPlaying()){
        this->animationSize.updateClockAnimation();
        edk::size2f32 sizeTemp;
        sizeTemp.width = this->animationSize.getClockX(&success);
        if(success){
            sizeTemp.height = this->animationSize.getClockY(&success);
            if(success){
                this->setScale(sizeTemp);
            }
        }
    }

    return ret;
}

//draw the text
void edk::fonts::FontMap::draw(edk::color4f32 color){
    this->color = color;
    //this->map.draw(color);
    this->draw(this->origin,this->last,color);
}
void edk::fonts::FontMap::draw(edk::float32 r,edk::float32 g,edk::float32 b,edk::float32 a){
    this->color = edk::color4f32(r,g,b,a);
    //this->map.draw(color);
    this->draw(this->origin,this->last,color);
}
void edk::fonts::FontMap::draw(edk::float32 r,edk::float32 g,edk::float32 b){
    this->draw(r,g,b,1.f);
}
void edk::fonts::FontMap::draw(){
    this->draw(this->origin,this->last,this->color);
}
void edk::fonts::FontMap::drawWire(edk::color4f32 color){
    this->color = color;
    //this->map.drawWire(color);
    this->drawWire(this->origin,this->last,color);
}
void edk::fonts::FontMap::drawWire(edk::float32 r,edk::float32 g,edk::float32 b,edk::float32 a){
    this->color = edk::color4f32(r,g,b,a);
    //this->map.drawWire(color);
    this->drawWire(this->origin,this->last,color);
}
void edk::fonts::FontMap::drawWire(edk::float32 r,edk::float32 g,edk::float32 b){
    this->drawWire(r,g,b,1.f);
}
void edk::fonts::FontMap::drawWire(){
    this->drawWire(this->origin,this->last,this->color);
}
void edk::fonts::FontMap::drawSelection(){
    this->drawSelection(this->origin,this->last);
}
//draw the pivo
void edk::fonts::FontMap::drawPivo(edk::float32 size,edk::color3f32 color){
    this->map.drawPivo(size,color);
}

//remove the fontImage
void edk::fonts::FontMap::removeFontImage(){
    //remove the tileSet from map
    this->map.removeTileSet();
    this->list.removeFontSet(this->set);
    this->set=NULL;
}

void edk::fonts::FontMap::animationEnd(edk::animation::InterpolationGroup* animation){
    //run the animation callback
    edk::uint32 size = this->treeCallbacks.size();
    bool isOrigin=false;
    if(animation == &this->animOrigin) isOrigin=true;
    for(edk::uint32 i=0u;i<size;i++){
        this->treeCallbacks.getElementInPosition(i)->animationEnd(this,isOrigin);
    }
}
